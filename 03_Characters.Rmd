---
title: "Visualizing characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Character reconstructions {#reconstructions}

```{R load_character_data, echo=FALSE}
library('Inapp')
str_replace <- stringi::stri_replace_all_fixed
tree <- iw.trees[[3]][[1]]
tree$edge.length <- rep(1, nrow(tree$edge))

LookUpReference <- function (keys, original, Format) {
  keys <- gsub("~", "", keys, fixed=TRUE)
  if (length(keys) == 0) {
    return (character(0))
  } else if (length(keys) == 1) {
    matches <- grepl(keys, refKeys, fixed=TRUE)
    if (sum(matches) == 1) {
      Format(refKeys[matches], original)
    } else {
      paste0('<mark>', original, '</mark>')
    }
  } else {
    matches <- vapply(keys, FUN=grepl, FUN.VALUE=logical(length(refKeys)), refKeys, fixed=TRUE)
    ret <- paste0('<mark>', original, '</mark>')
    uniques <- colSums(matches) == 1
    ret[uniques] <- vapply(which(uniques), function (i) 
      Format(refKeys[matches[, i]], original[i]), character(1))
    
    # Return:
    ret
  }
}

ConvertReferences <- function (string) {
  noParentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)? (\\d\\d\\d\\d\\w?)"
  ReplNoPar <- function (keyedText, oldKey, original) {
    str_replace(keyedText, oldKey,
                LookUpReference(oldKey, original, function(x, raw) paste0('@', x)),
                vectorize_all=FALSE)
  }
  
  parentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)? \\((\\d\\d\\d\\d\\w?)([^\\)]*)\\)"
  ReplPar <- function (keyedText, oldKey, original) {
    str_replace(keyedText, pattern=oldKey, replacement=
                LookUpReference(oldKey, original, function (x, raw)
                  paste0(gsub(parentheses, "\\1\\2", raw, perl=TRUE), ' [-@', x,
                  gsub(parentheses, "\\4", raw, perl=TRUE), ']')),
                vectorize_all=FALSE)
  }
  
  ReplaceRefs <- function (pattern, strings, Replace) {
    execResults <- gregexpr(pattern, strings, perl=TRUE)
    matchText <- lapply(regmatches(strings, execResults), unique)
    keyed <- gsub(pattern, "~~~\\1\\3~~~", strings, perl=TRUE)
    keys <- lapply(matchText, function (x) unique(gsub(pattern, "~~~\\1\\3~~~",
                                                       x, perl=TRUE)))
    toEdit <- which(vapply(keys, length, 0) > 0)
    strings[toEdit] <- vapply(toEdit, function (i) {
      Replace(keyed[i], keys[[i]], matchText[[i]])
    }, character(1))
    # Return:
    strings
  }
  
  matches <- grepl(noParentheses, string)
  string[matches] <- ReplaceRefs(noParentheses, string[matches], ReplNoPar)
  
  matches <- grepl(parentheses, string)
  string[matches] <- ReplaceRefs(parentheses, string[matches], ReplPar)
  
  string <- gsub("\\(([^\\)]*?@\\S+?[^\\)]*)\\)", "[\\1]", string, perl=TRUE)
  
  # Return:
  string
}

MorphoBankDecode <- function (string) {
  string <- gsub("^n", "  \n", string, fixed=TRUE)
  string <- gsub("''", "'", string, fixed=TRUE)
  string <- gsub(" - ", " -- ", string, fixed=TRUE)
  string <- gsub("(\\d)\\-(\\d)", "\\1--\\2", string, perl=TRUE)
  string <- gsub("(\\d) ?um\\b", "\\1 &mu;m", string, perl=TRUE)
  string <- gsub(" et al ", " et al. ", string, fixed=TRUE)
  string <- gsub(" et alia", " et al.", string, fixed=TRUE)
  
  # Return:
  ConvertReferences(string)
}

EndSentence <- function (string) gsub("\\s*\\.?\\s*\\.$", ".", paste0(string, '.'), perl=TRUE)

ReadNotes <- function (filepath) {
  lines <- readLines(filepath)
  charNote.pattern <- "^\\s+TEXT\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  stateNote.pattern <- "^\\s+TEXT\\s+TAXON=(\\d+)\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  upperLines <- toupper(lines)
  notesStart <- which(upperLines == "BEGIN NOTES;")
  endBlocks <- which(upperLines == "ENDBLOCK;")
  if (length(notesStart) == 0) {
    return(list("NOTES block not found in Nexus file."))
  } else if (length(notesStart) > 1) {
    return(list("Multiple NOTES blocks found in Nexus file."))
  } else {
    notesEnd <- endBlocks[endBlocks > notesStart][1] - 1L
    notesLines <- lines[(notesStart + 1):notesEnd]
    charNote.matches <- grepl(charNote.pattern, notesLines, perl=TRUE)
    charNotes <- gsub(charNote.pattern, "\\2",
                       notesLines[charNote.matches], perl=TRUE)
    charNotes <- EndSentence(MorphoBankDecode(charNotes))
    charNumbers <- gsub(charNote.pattern, "\\1",
                              notesLines[charNote.matches], perl=TRUE)
    
    stateNote.matches <- grepl(stateNote.pattern, notesLines, perl=TRUE)
    stateNotes <- gsub(stateNote.pattern, "\\3",
                       notesLines[stateNote.matches], perl=TRUE)
    stateNotes <- EndSentence(MorphoBankDecode(stateNotes))
    stateTaxon <- gsub(stateNote.pattern, "\\1",
                              notesLines[stateNote.matches], perl=TRUE)
    stateChar  <- gsub(stateNote.pattern, "\\2",
                              notesLines[stateNote.matches], perl=TRUE)
    
    charNotes <- lapply(seq_len(max(c(stateChar, charNumbers))), function (i) {
      ret <- list(
        charNotes[charNumbers == i],
        stateNotes[stateChar == i])
      names(ret[[2]]) <- stateTaxon[stateChar == i]
      
      # Return:
      ret
    })
    names(charNotes) <- charNumbers
    
    # Return:
    charNotes
  }
}

PrintStates <- function (states) {
  states <- gsub("^'(.*)'$", "\\1", states)
  tokens <- seq_along(states) - 1L
  if (states[1] == "") {
    states <- states[-1]
    tokens <- tokens[-1]
    transformational <- TRUE
  } else {
    transformational <- FALSE
  }
  cat(paste0(" > ", tokens, ": ", states, "  \n"))
  cat("> ", if (transformational) "Transformational" else "Neomorphic", " character.  \n>\n")
}

char_names <- gsub("^'(.+)'$", "\\1", colnames(my_chars))
n_char <- ncol(my_chars)
char_parts <- strsplit(char_names, ": ")
char_nesting <- vapply(char_parts, length, 0L)
char_notes <- ReadNotes(filename)
taxa_names <- c("Namacalathus", rownames(my_chars))
taxa_plaintext <- gsub("_", " ", taxa_names, fixed=TRUE)
taxa_italic <- paste0("_", taxa_plaintext, "_")
Italicize <- function (string) {
  string <- gsub(paste0("\\b(", 
                        paste0(gsub("_", "|", fixed = TRUE,
                                    c(taxa_names,
                                      'Bethia', 'Eichwaldia', 'Eoorthis',
                                      'Hadrotreta', 'Lochkothele',
                                      'comleyensis', 'decaius',
                                      'vascula', 'genitalia','lateralia',
                                      'media', 'myaria', 'terminalia',
                                      'et al\\.', 'et al')),
                               collapse='|'),
              ")\\b"), "_\\1_", string, perl=TRUE, ignore.case=TRUE)
  gsub("\\b([A-Z]\\.) _([a-z])", "_\\1 \\2", string, perl=TRUE)
}
#treeCol <- tipCol[tree$tip.label]
```

This page defines each characer and accounts for its coding in particular taxa.  Citations for all codings can be found by browsing the [morphological dataset](#dataset) on MorphoBank ([project 2800](https://morphobank.org/permalink/?P2800)).

The _Inapp_ _R_ package [@Brazeau2018] was used to map each character onto one of the most parsimonious trees (obtained under implied weighting, $k = 4.5$):


```{R print_each_character, echo=FALSE, fig.height=6.6, fig.width=7.1, results="asis"}
Header <- function (level, content) paste0("  \n", paste0(rep('#', level), collapse=''), " ", content, "  \n")
PrintDivision <- function (parts) cat(Header(2L, paste(char_parts_i[1:parts],
                                                       collapse=': ')))
PrintCharacter <- function () {
  cat(Header(3L, paste0("[", i, "] ", 
                        paste0(char_parts_i[if(char_nesting[i] < 4) char_nesting[i] else 3:char_nesting[i]], collapse=': '), " {-}")))
}
PrintSoloCharacter <- function () {
  cat(Header(2L, paste0(paste(char_parts_i, collapse=': '),
                        " [", i, "] ")))
}

for (i in seq_len(n_char)) {
  
  char_parts_i <- char_parts[[i]]
  if (i > 1) char_parts_last <- char_parts[[i - 1L]]
  
  if (char_nesting[i] == 1
      && (i == n_char || char_parts[[i + 1L]][1] != char_parts_i[1])) {
    PrintSoloCharacter()
  } else if (i == 1) {
    PrintDivision(1)
    PrintCharacter()
  } else if (char_parts_last[1L] != char_parts_i[1L]) {
    PrintDivision(2)
    PrintCharacter()
  } else if (length(char_parts_i) > 1L) {
    if (length(char_parts_last) < 2L) {
      PrintDivision(2)
      PrintCharacter()
    } else if (char_parts_last[2L] != char_parts_i[2L]) {
      if (char_nesting[i - 1L] > 2
          && (
            i == n_char
            || char_nesting[i + 1L] < 2
            || char_parts_i[2] != char_parts[[i + 1L]][2]
            )
          ) {
        PrintSoloCharacter()
      } else {
        if (char_nesting[i - 1L] > 2) {
          PrintDivision(2)
        }
        PrintCharacter()
      }
    } else {
      PrintCharacter()
    }
  } else {
    PrintCharacter()
  }

  
  par(mar=rep(0.2, 4), cex=0.7)
  
  plot.states.matrix(apply.reconstruction(tree, my_chars[, i]),
                     passes=0, counts=1:2, show.labels=1,
                     col.states=TRUE, state.labels=my_states[[i]],
                     #tip.col=treeCol, 
                     use.edge.length=TRUE, legend.pos='topright')
  
  cat(paste0("  \n\n **Character ", i, ": ", char_names[i], "**  \n\n"))
  PrintStates(my_states[[i]])
  cat("  \n\n")
  char_notes_i <- char_notes[[i]]
  state_notes_i <- char_notes_i[[2]]
  if (length(char_notes_i[[1]]) > 0) cat(Italicize(char_notes_i[[1]]), "  \n")
  if (length(state_notes_i) > 0) {
    cat("  \n", paste0("<div class='state-note'>", taxa_italic[as.integer(names(state_notes_i))],
                      ": ", Italicize(state_notes_i), "</div>  \n  \n"))
  }
  cat("  \n") # Clear line, ready for next block
}
```
