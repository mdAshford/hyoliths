---
title: "TreeSearch results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Parsimony analysis {#treesearch}

The phylogenetic dataset contains a considerable proportion of inapplicable codings (`r sum(my_chars == '-')`/`r length(my_chars)` = `r round(sum(my_chars == '-') / length(my_chars), 3) * 100`% of tokens), which are known to introduce error and bias to phylogenetic reconstruction when the Fitch algorithm is employed [@Maddison1993;@Brazeau2018].  As such, we employed a new tree-scoring algorithm that correctly handles inapplicable data [@Brazeau2018], implemented in the _MorphyLib_ C library [@Brazeau2017Morphylib].  We employed the R package _TreeSearch_ v0.1.2 [@Smith2018TreeSearch] to conduct phylogenetic tree search with this algorithm.

As this is a new method, we also employed the traditional, Fitch algorithm, even though this approach is known to generate erroneous trees.  The results of this analysis can be viewed in [a later section](#fitch).


## Search parameters

Heuristic searches were conducted using the parsimony ratchet [@Nixon1999] under equal and implied weights [@Goloboff1997].  The consensus tree presented in the main manuscript represents a strict consensus of all trees that are most parsimonious under one or more of the concavity constants (_k_) 2, 3, 4.5, 7, 10.5, 16 and 24, an approach that has been shown to produce higher accuracy (i.e. more nodes and quartets resolved correctly) than equal weights at any given level of precision [@Smith2017].

## Analysis 

The R commands used to conduct the analysis are reproduced below.
The results can most readily be replicated using the [R markdown files](https://github.com/ms609/hyoliths/) (.Rmd) used to generate these pages.

### Initialize and load data

```{r treesearch-load-morphoBank, echo=TRUE}
# Load data from locally downloaded copy of MorphoBank matrix
my_data <- ReadAsPhyDat(filename)
my_data$Namacalathus <- NULL # Exclude Namacalathus
iw_data <- PrepareDataIW(my_data)
```

### Generate starting tree

Start by quickly rearranging a neighbour-joining tree, rooted on the outgroup.

```{R treesearch-starting-tree, echo=TRUE}
nj.tree <- NJTree(my_data)
rooted.tree <- EnforceOutgroup(nj.tree, outgroup)
start.tree <- TreeSearch(tree=rooted.tree, dataset=my_data, maxIter=3000,
                         EdgeSwapper=RootedNNISwap, verbosity=0)
```

### Implied weights analysis

The position of the root does not affect tree score, so we keep it fixed (using `RootedXXXSwap` functions) to avoid unnecessary swaps.

```{r treesearch-implied-weights-analysis, echo=TRUE, eval=FALSE}
for (k in kValues) {
  iw.tree <- IWRatchet(start.tree, iw_data, concavity=k,
                       ratchHits = 60, searchHits=55,
                       swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap),
                       verbosity=0L)
  score <- IWScore(iw.tree, iw_data, concavity=k)
  # Write a single best tree
  write.nexus(iw.tree,
              file=paste0("TreeSearch/hy_iw_k", k, "_", 
                          signif(score, 5), ".nex", collapse=''))

  iw.consensus <- IWRatchetConsensus(iw.tree, iw_data, concavity=k,
                  swappers=list(RootedTBRSwap, RootedNNISwap),
                  searchHits=55,
                  nSearch=150, verbosity=0L)
  write.nexus(iw.consensus, 
              file=paste0("TreeSearch/hy_iw_k", k, "_", 
                          signif(IWScore(iw.tree, iw_data, concavity=k), 5),
                          ".all.nex", collapse=''))
}
```

### Equal weights analysis

```{r treesearch-equal-weights-analysis, echo=TRUE, eval=FALSE}
ew.tree <- Ratchet(start.tree, my_data, verbosity=0L,
                   ratchHits = 25, searchHits=55, # ratchHits = 10 not enough
                   swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap))
ew.consensus <- RatchetConsensus(ew.tree, my_data, nSearch=150, searchHits = 55,
                                 swappers=list(RootedTBRSwap, RootedNNISwap),
                                 verbosity=0L)
write.nexus(ew.consensus, file=paste0(collapse='', "TreeSearch/hy_ew_",
                                      Fitch(ew.tree, my_data), ".nex"))
```

## Results

```{R treesearch-load-trees, echo=FALSE}
# Read results from files
ew.best <- list.files('TreeSearch', pattern='hy_ew_\\d*\\.nex', full.names=TRUE)
ew.trees <- unique(read.nexus(file=ew.best[which.max(file.mtime(ew.best))]))
iw.trees <- lapply(kValues, function (k) {
  iw.best <- list.files('TreeSearch', 
                      pattern=paste0('hy_iw_k',
                                     gsub('\\.', '\\\\.', k),
                                     '_\\d+\\.?\\d*\\.all\\.nex'),
                      full.names=TRUE)
  # Return:
  if (length(iw.best) == 0) {
    list()
  } else {
    unique(read.nexus(iw.best[which.max(file.mtime(iw.best))]))
  }
})

if (length(kValues) != 7) stop("You need to change this ugly code manually")
# Eugh.  Still, easier than trying to battle multiPhylo's compression
allTrees <- c(ew.trees, iw.trees[[1]], iw.trees[[2]],
           iw.trees[[3]], iw.trees[[4]], iw.trees[[5]],
           iw.trees[[6]], iw.trees[[7]])

nTip <- Ntip(allTrees[[1]])
tipLabels <- sort(allTrees[[1]]$tip.label)
powersOf2 <- 2^(seq_len(nTip)- 1)
SplitNumber <- function (tips, tr) sum(powersOf2[tipLabels %in% tr$tip.label[tips]])
splitOccurrences <- table(vapply(allTrees, function (tr) {
  vapply(Descendants(tr, nTip + seq_len(nTip - 1L), type='tips'),
         SplitNumber, double(1), tr)
  }, double(nTip - 1L)))
SplitSupport <- function(tr) {
  splits <- Descendants(tr, nTip + seq_len(Nnode(tr)), type='tips')
  splitNumbers <- vapply(splits, SplitNumber, double(1), tr)
  splitOccurrences[as.character(splitNumbers)]
}
```

(ref:ts-all-cons) Consensus of all parsimony results.  

(ref:node-support) Node labels denote the proportion of trees obtained under all analytical conditions that support the clade.  

```{r treesearch-maj-consensus, fig.cap="(ref:ts-all-cons) (ref:node-support)", fig.width=6, fig.height=5, echo=FALSE}
majCon <- consensus(allTrees, p=0.5)
supporters <- SplitSupport(majCon)

ColPlot(majCon)
nodelabels(paste0("\n\n", signif(supporters / length(allTrees), 3)),
           col=NodeColour(round(supporters / length(allTrees), 2)),
           adj=0, pos=2, frame='none', cex=0.75)

```

(ref:ts-trim-cons) Consensus of all parsimony results, with taxa omitted to show underlying clade support.  

```{r treesearch-maj-consensus-pruned, fig.cap="(ref:ts-all-cons) (ref:node-support)", fig.width=6, fig.height=5, echo=FALSE}
omit <- c("Micrina", 'Mickwitzia_muralensis',
       'Heliomedusa_orienta')
majCon <- ConsensusWithout(allTrees, omit, p=0.5)
nTip <- Ntip(majCon)
splits <- Descendants(majCon, nTip + seq_len(Nnode(majCon)), type='tips')
splits <- lapply(splits, function (x) sort(majCon$tip.label[x]))
internalNodes <- nTip + seq_len(nTip - 1)
prunedTrees <- lapply(allTrees, drop.tip, tip=omit)
supporters <- vapply(splits, function (tips) sum(vapply(prunedTrees, function (tree) {
  treeSplits <- Descendants(tree, internalNodes, type='tips')
  splitLengths <- vapply(treeSplits, length, integer(1))
  tipLabels <- tree$tip.label
  treeSplits <- vapply(treeSplits[splitLengths == length(tips)],
                       function (x) sort(tipLabels[x]), character(length(tips)))
  any(apply(treeSplits, 2, identical, tips))
}, logical(1))), integer(1))


ColPlot(majCon)
nodelabels(paste0("\n", signif(supporters / length(allTrees), 3)),
           col=NodeColour(round(supporters / length(allTrees), 2)),
           adj=0, pos=2, frame='none', cex=0.75)

```

(ref:ts-iw-cons) Consensus of implied weights analyses at all values of _k_. Wildcard taxa have been excluded from the consensus tree shown above to improve resolution.

```{r treesearch-iw-consensus, fig.cap="(ref:ts-iw-cons)", fig.width=6, fig.height=5, echo=FALSE}
ColPlot(ConsensusWithout(lapply(iw.trees, consensus), omit))
ColMissing(omit)
```

(ref:ts-iw-indiv) Consensus trees of implied weights analyses

(ref:first-panels) at all values of _k_, and at the individual values _k_ = `r kValues[1]`, `r kValues[2]` and `r kValues[3]`.

(ref:second-panels) at _k_ = `r paste(kValues[4:6], sep=', ')` and `r kValues[7]`.

\clearpage 

```{r treesearch-all-iw-results, fig.width=7.1, fig.height=8, fig.cap="(ref:ts-iw-indiv) (ref:first-panels)", echo=FALSE}
# Plot consensus results
par(mfrow=c(2, 2), mar=rep(0.2, 4))

ColPlot(consensus(lapply(iw.trees, consensus)))
text(-0.5, 1, pos=4, "Consensus of all k values", cex=0.8)

# Plot results for each value of k
PlotPanel <- function (i) {
  ColPlot(consensus(iw.trees[[i]]))
  text(1, 1, paste0('k = ', kValues[i]), pos=4)
}
PlotPanel(1)
PlotPanel(2)
PlotPanel(3)
```

\clearpage 

```{R treesearch-iw-results-3, fig.width=7.1, fig.height=8, fig.cap="(ref:ts-iw-indiv) (ref:second-panels)", echo=FALSE}
par(mfrow=c(2, 2), mar=rep(0.2, 4))
PlotPanel(4)
PlotPanel(5)
PlotPanel(6)
PlotPanel(7)
```

\clearpage

```{r treesearch-equal-weights-results, fig.cap="Strict consensus of most parsimonious trees under equally weighted parsimony", echo=FALSE}
ColPlot(consensus(ew.trees))
```

<!--
```{R treesearch-equal-weights-pruned-consensus, fig.cap="Strict consensus of equal weights results, taxa excluded", echo=FALSE}
omit <- c('none')
ColPlot(ConsensusWithout(ew.trees, omit))
ColMissing(omit)
```
-->

\clearpage
