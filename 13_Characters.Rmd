---
title: "Visualizing characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Character reconstructions {#reconstructions}

This page provides definitions for each of the characters in our matrix, and justifies codings in particular taxa where relevant.  Further citations for codings that are not discussed in the text can be viewed by browsing the [morphological dataset](#dataset) on MorphoBank ([project 2800](https://morphobank.org/permalink/?P2800)). <mark>This link will become live on publication of the paper. Referees should follow the pre-publication link to the dataset that has been provided in the main manuscript.</mark>

Alongside its definition, each character has been mapped onto a tree.
 `r if (knitr::is_html_output()) 'Any of the optimal trees can be selected by modifying the tree number listed above each diagram.' else 'Here, we have arbitrarily selected one most parsimonious tree obtained under implied weighting, $k = 4.5$. Other trees can be viewed in the HTML version of this document at \\href{https://ms609.github.io/hyoliths/reconstructions.html}{ms609.github.io/hyoliths}.'`
Each tip is labelled according to its coding in the matrix.  These states have been used to reconstruct the condition of each internal node, using the parsimony method of @Brazeau2018 as implemented in the _Inapp_ _R_ package.

We emphasize that different trees will give different reconstructions.  The character mappings are not intended to definitively establish how each character evolved, but to help the reader quickly establish how each character has been coded, and to visualize at a glance how each character fits onto a given tree.

```{R states matrix function, echo=FALSE, message=FALSE}
NewickTree <- function(tree) gsub('_', ' ', write.tree(tree), fixed=TRUE)
MatrixData <- function (x, state.labels) {
  tree <- states_matrix$tree
  regions <- states_matrix$regions
  changes <- states_matrix$changes
  n_tip <- states_matrix$n_tip
  plot.convert.state <- function(character, missing = FALSE) {
    plot.convert.inappli <- function(X) {
      return(ifelse(X == -1, "-", X))
    }
    plot.convert.missing <- function(X, all_states) {
      if (length(all_states) > 1 && length(X) == length(all_states) && 
        all(sort(X) == sort(all_states))) {
        return("?")
      }
      else {
        return(X)
      }
    }
    if (missing) {
      all_states <- unique(unlist(character))
      character <- lapply(character, plot.convert.missing, 
        all_states)
    }
    character <- lapply(character, plot.convert.inappli)
    return(unlist(lapply(character, function(X) paste(as.character(X), 
      collapse = ""))))
  }
  get.NA.edges <- function(states_matrix, tree, pass = 4) {
    check.applicable <- function(nodes, states_matrix, pass) {
      node1 <- states_matrix[[pass + 1]][nodes[1]][[1]]
      node2 <- states_matrix[[pass + 1]][nodes[2]][[1]]
      all_char <- sort(unique(unlist(states_matrix$Char)))
      options(warn = -1)
      node2 <- ifelse(all(node2 == all_char), node1, node2)
      options(warn = 0)
      return(ifelse(all(c(node1, node2) == -1), 0, 1))
    }
    return(apply(tree$edge, 1, check.applicable, states_matrix, 
      pass))
  }
  
  edge_col <- "black"
  tips_labels <- plot.convert.state(states_matrix[[1]][1:n_tip], missing = TRUE)

  tips_colours <- tips_labels
  tips_colours[nchar(tips_labels) > 1] <- "?"
  max_colour <- max(as.integer(tips_colours[tips_colours %in% 
    0:9]))
  state_colours <- c(Inapp::brewer[[max_colour + 1]], 
    "grey")
  names(state_colours) <- c(0:max_colour, "?")
  if ("-" %in% tips_labels) state_colours <- c(state_colours, `-` = "lightgrey")
  edge_palette <- state_colours
  edge_palette["?"] <- "darkgrey"

  if (!is.null(unlist(states_matrix$Up2))) {
    na_edges <- get.NA.edges(states_matrix, tree, pass = 4) == 
      1
    edge_final <- ifelse(na_edges, "0", "-")
    edge_col <- ifelse(na_edges, "black", "grey")
  } else {
    edge_final = 0
  }
  #if (!is.null(unlist(states_matrix$Up1))) {
    if (!is.null(unlist(states_matrix$Up2))) {
      final_state <- states_matrix$Up2
    } else {
      final_state <- states_matrix$Up1
    }
    all_states <- -1:max_colour
    col_states <- c("-", 0:max_colour)
    colour.edge <- function(edge) {
      parent <- all_states %in% final_state[[edge[1]]]
      child <- all_states %in% final_state[[edge[2]]]
      common <- parent & child
      if (sum(common) == 1) {
        col_states[common]
      }
      else if (sum(child) == 1) {
        col_states[child]
      }
      else if (sum(parent) == 1 && !identical(parent, 
        (col_states == "-"))) {
        col_states[parent]
      }
      else "?"
    }
    edge_final <- apply(tree$edge, 1, colour.edge)
    edge_col <- as.character(edge_palette[edge_final])
  #}
  
  if (length(state.labels) == length(edge_palette) - 2) {
    state.labels <- c(state.labels, "Ambiguous", "Inapplicable")
  } else if (length(state.labels) == length(edge_palette) - 1) {
    state.labels <- c(state.labels, "Ambiguous")
  } else if (length(state.labels) != length(edge_palette)) {
    warning("State labels do not seem to match states.  You need to label all states from 0 to the maximum observed.")
  }
  
  edge_col_array <- paste0('["', paste0(edge_col, collapse='", "'), '"]')
  
  state_labels <- paste(names(edge_palette), gsub("^['\"]|['\"]$", 
      "", state.labels), sep = ": ")
  observed <- names(edge_palette) %in% edge_final
  list (edge_col = edge_col,
        edge_col_array = edge_col_array,
        legend = state_labels[observed], 
        legend_col = edge_palette[observed],
        tips_labels = tips_labels,
        tips_colours = as.character(state_colours[tips_colours]))
}
```
```{R char loading functions, echo=FALSE}
StrReplace <- stringi::stri_replace_all_fixed

LookUpReference <- function (keys, original, prefix='', suffix='') {
  keyParts <- "^~~~(.+?)(\\b.*)~~~$"
  keySuffixes <- gsub(keyParts, "\\2", keys, perl=TRUE)
  keys <- gsub(keyParts, "\\1", keys, perl=TRUE)
  if (length(keys) == 0) {
    return (character(0))
  } else if (length(keys) == 1) {
    matches <- grepl(keys, refKeys, fixed=TRUE)
    if (sum(matches) == 1) {
      paste0(prefix, refKeys[matches], keySuffixes, suffix)
    } else {
      paste0('<mark>', original, '</mark>')
    }
  } else { # length(keys) > 1
     # initialize
    ret <- paste0('<mark>', original, '</mark>')
    if (length(suffix) == 1) suffix <- rep(suffix, length(keys))
    if (length(prefix) == 1) prefix <- rep(prefix, length(keys))
    
    matches <- vapply(keys, FUN=grepl, FUN.VALUE=logical(length(refKeys)), refKeys, fixed=TRUE)
    uniques <- colSums(matches) == 1
    ret[uniques] <- vapply(which(uniques), function (i) 
      paste0(prefix[i], refKeys[matches[, i]], keySuffixes[i], suffix[i])
      , character(1))
    
    # Return:
    ret
  }
}

ConvertReferences <- function (string) {
  noParentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)?,? (\\d\\d\\d\\d\\w?)\\b"
  ReplNoPar <- function (keyedText, oldKey, original) {
    StrReplace(keyedText, oldKey,
                LookUpReference(oldKey, original, prefix='@'),
               vectorize_all=FALSE)
  }
  
  parentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)?,? \\((\\d\\d\\d\\d\\w?)\\b([^\\)]*)\\)"
  ReplPar <- function (keyedText, oldKey, original) {
    StrReplace(keyedText, oldKey,
                LookUpReference(oldKey, original, 
                  prefix=paste0(gsub(parentheses, "\\1\\2", original, perl=TRUE), ' [-@'),
                  suffix=']'
                ), vectorize_all=FALSE)
                
  }
  
  ReplaceRefs <- function (pattern, strings, Replace) {
    execResults <- gregexpr(pattern, strings, perl=TRUE)
    matchText <- lapply(regmatches(strings, execResults), unique)
    keyed <- gsub(pattern, "~~~\\1\\3\\4~~~", strings, perl=TRUE)
    keys <- lapply(matchText, function (citation) {
      ret <- gsub(pattern, "~~~\\1\\3\\4~~~", citation, perl=TRUE)
      duplicates <- ret[duplicated(ret)]
      substr(ret[duplicated(ret)], nchar(duplicates)-6, nchar(duplicates)-3) <- '!x2!'
      ret
    })
    toEdit <- which(vapply(keys, length, 0) > 0)
    strings[toEdit] <- vapply(toEdit, function (i) {
      Replace(keyed[i], keys[[i]], matchText[[i]])
    }, character(1))
    # Return:
    strings
  }
  
  matches <- grepl(noParentheses, string)
  string[matches] <- ReplaceRefs(noParentheses, string[matches], ReplNoPar)
  
  matches <- grepl(parentheses, string)
  string[matches] <- ReplaceRefs(parentheses, string[matches], ReplPar)
  
  string <- gsub("\\(([^\\)]*?@\\S+?[^\\)]*)\\)", "[\\1]", string, perl=TRUE)
  
  # Return:
  string
}

MorphoBankDecode <- function (string) {
  string <- gsub("^n", "  \n", string, fixed=TRUE)
  string <- gsub("''", "'", string, fixed=TRUE)
  string <- gsub(" - ", " -- ", string, fixed=TRUE)
  string <- gsub("(\\d)\\-(\\d)", "\\1--\\2", string, perl=TRUE)
  string <- gsub("(\\d) ?um\\b", "\\1 Âµm", string, perl=TRUE)
  string <- gsub(" et al ", " et al. ", string, fixed=TRUE)
  string <- gsub(" et alia", " et al.", string, fixed=TRUE)
  
  # Return:
  ConvertReferences(string)
}

EndSentence <- function (string) {
  ret <- gsub("\\s*\\.?\\s*\\.$", ".", paste0(string, '.'), perl=TRUE)
  ret <- gsub("(\\.[\"'])\\.$", "\\1", ret, perl=TRUE)
}

ReadNotes <- function (filepath) {
  lines <- enc2utf8(readLines(filepath))
  charNote.pattern <- "^\\s+TEXT\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  stateNote.pattern <- "^\\s+TEXT\\s+TAXON=(\\d+)\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  upperLines <- toupper(lines)
  notesStart <- which(upperLines == "BEGIN NOTES;")
  endBlocks <- which(upperLines == "ENDBLOCK;")
  if (length(notesStart) == 0) {
    return(list("NOTES block not found in Nexus file."))
  } else if (length(notesStart) > 1) {
    return(list("Multiple NOTES blocks found in Nexus file."))
  } else {
    notesEnd <- endBlocks[endBlocks > notesStart][1] - 1L
    notesLines <- lines[(notesStart + 1):notesEnd]
    charNote.matches <- grepl(charNote.pattern, notesLines, perl=TRUE)
    charNotes <- gsub(charNote.pattern, "\\2",
                       notesLines[charNote.matches], perl=TRUE)
    charNotes <- EndSentence(MorphoBankDecode(charNotes))
    charNumbers <- gsub(charNote.pattern, "\\1",
                              notesLines[charNote.matches], perl=TRUE)
    
    stateNote.matches <- grepl(stateNote.pattern, notesLines, perl=TRUE)
    stateNotes <- gsub(stateNote.pattern, "\\3",
                       notesLines[stateNote.matches], perl=TRUE)
    stateNotes <- EndSentence(MorphoBankDecode(stateNotes))
    stateTaxon <- gsub(stateNote.pattern, "\\1",
                              notesLines[stateNote.matches], perl=TRUE)
    stateChar  <- gsub(stateNote.pattern, "\\2",
                              notesLines[stateNote.matches], perl=TRUE)
    
    seqAlongNotes <- seq_len(max(as.integer(c(stateChar, charNumbers))))
    charNotes <- lapply(seqAlongNotes, function (i) {
      ret <- list(
        charNotes[charNumbers == i],
        stateNotes[stateChar == i])
      names(ret[[2]]) <- stateTaxon[stateChar == i]
      
      # Return:
      ret
    })
    names(charNotes) <- seqAlongNotes
    
    # Return:
    charNotes
  }
}

IsTransformational <- function (states) {
  gsub("^'(.*)'$", "\\1", states)[1] == ""
}

PrintStates <- function (states) {
  states <- gsub("^'(.*)'$", "\\1", states)
  tokens <- seq_along(states) - 1L
  if (states[1] == "") {
    states <- states[-1]
    tokens <- tokens[-1]
    transformational <- TRUE
  } else {
    transformational <- FALSE
  }
  cat(paste0(" > ", tokens, ": ", states, "  \n"))
  cat("> ", if (transformational) "Transformational" else "Neomorphic", "character.  \n>\n")
}

Italicize <- function (string) {
  string <- gsub(paste0("\\b(", 
                        paste0(gsub("_", "|", fixed = TRUE,
                                    c(taxa_names,
                                      'Bethia', 'Discinisca', 
                                      'Eichwaldia', 'Electra', 'Enchytraeus',
                                      'Eoorthis', 'Galeolaria', 'Gryphus',
                                      'Hadrotreta', 'Harmothoe', 'Hydroides', 'Kraussina',
                                      'Lochkothele', 'Loxosoma',
                                      'Magelona', 'Mopalia', 'Neocrania',
                                      'Oikozetetes',
                                      'Paracraniops', 'Paramicrocornus',
                                      'Phascolion', 'Phoronopsis',
                                      'Themiste', 'Tubulipora', 
                                      'comleyensis', 'decaius',
                                      'schucherti', 'tenuis', 'worsleyi',
                                      'vascula', 'genitalia','lateralia',
                                      'media', 'myaria', 'terminalia',
                                      'levator ani',
                                      'et al\\.', 'et al', 'sensu')),
                               collapse='|'),
              ")\\b"), "_\\1_", string, perl=TRUE, ignore.case=FALSE)
  gsub("\\b([A-Z]\\.) _([a-z])", "_\\1 \\2", string, perl=TRUE)
}
```
```{R load-the-characters, echo=FALSE, message=FALSE}
if (!require('Inapp')) devtools::install_github('TGuillerme/Inapp')
library('Inapp')
if (knitr::is_html_output()) {
  trees <- unique(allTrees)
} else {
  trees <- iw.trees[[ceiling(length(iw.trees)/2L)]][2] # Single [] to keep as a list of 1 tree.
}
tree <- trees[[1]]
tree$edge.length <- rep(1, nrow(tree$edge))
rootedTrees <- lapply(trees, RootTree, outgroupTips=c('Dentalium', 'Serpula'))

char_names <- gsub("^'(.+)'$", "\\1", colnames(my_chars))
n_char <- ncol(my_chars)
char_parts <- strsplit(char_names, ": ")
char_nesting <- vapply(char_parts, length, 0L)
char_notes <- ReadNotes(filename)
taxa_names <- unique(c("Namacalathus", rownames(my_chars)))
taxa_sort <- taxa_names
taxa_plaintext <- gsub("_", " ", taxa_names, fixed=TRUE)
taxa_italic <- paste0("_", taxa_plaintext, "_")

index <- attr(my_data, 'index')
ci_text <- vapply(trees, function (tree) {
  fitch_consistency_index <- CI(tree, fitch_data, sitewise=TRUE)
  fitch_steps <- fitch(tree, fitch_data, site='site')[index]
  min_steps <- fitch_consistency_index * fitch_steps
  # Maximum steps is tricky to calculate, so we'll leave RI [= max-obs / max-min]
  # unless referees insist on it; neither it nor CI mean much in any case.
  fitch_retention_index <- RI(tree, fitch_data, sitewise=TRUE)
  fitch_retention_index <- ifelse(fitch_retention_index == 'NaN', 'n/a', signif(fitch_retention_index, 2))
  paste0('CI = ', signif(min_steps / FitchSteps(tree, my_data)[index], 2),
                  '; Fitch CI = ', signif(fitch_consistency_index, 2),
                  '; Fitch RI = ', fitch_retention_index)
}, character(n_char), USE.NAMES=FALSE)
```
```{R SVG-setup, echo=FALSE, results="asis"}
fileNamer <- 'Brachiopod_phylogeny_files/figure-html/tree%s-char%s.svg'
if (knitr::is_html_output()) {
  CheckDirExists <- function (x) if (!dir.exists(x)) dir.create(x)
  CheckDirExists('_book')
  CheckDirExists('_book/Brachiopod_phylogeny_files')
  CheckDirExists('_book/Brachiopod_phylogeny_files/figure-html')
  nTree <- c(length(ew.trees), vapply(iw.trees, length, 0))
  analysisNames <- c('Equal weights', paste0(c('Implied weights, k = ', rep('IW, k = ', length(kValues) - 1L)), kValues))
  treeNames <- rep(analysisNames, nTree)
  nTrees <- sum(nTree)
  treeIndex <- vapply(allTrees,
                      function (tr1)
                        which(vapply(trees, all.equal, logical(1), tr1, 
                                     use.tip.label=TRUE, use.edge.length=FALSE)),
                      integer(1))
  
  svgWidth <- 682
  svgHeight <- 612
  treeXMargins <- c(5L, 200L)
  treeYMargins <- c(7L, 8L)
  
  n_tree <- length(trees)
  eachTree <- seq_len(n_tree)
  n_tip <- length(trees[[1]]$tip.label)
  internal <- n_tip + seq_len(n_tip - 1)
  terminal <- seq_len(n_tip)
  tipLabel <- matrix('', n_tree, n_tip)
  n_edge <- dim(tree$edge)[1]
  eachEdge <- seq_len(n_edge)
  parent <- child <- matrix(0, n_tree, n_edge)
  xStep <- nodeX <- nodeY <- vector('list', n_tree)
  yStep <- round((svgHeight - treeYMargins[2] - treeYMargins[1]) / n_tip, 1)
  textY <- 3L
  nAnalyses <- length(analysisNames)
  for (i in eachTree) {
    tree <- rootedTrees[[i]]
    tipLabel[i, ] <- tree$tip.label
    treeEdge <- tree$edge
    parent[i, ] <- treeEdge[, 1]
    child[i, ] <- treeEdge[, 2]
    ancestors <- Ancestors(tree, type='all')
    nAncestors <- vapply(ancestors, length, 1)
    xStep[[i]] <- round(seq(treeXMargins[1], to=svgWidth-treeXMargins[2],
                       len=max(nAncestors) + 1L), 1)
    nodeX[[i]] <- xStep[[i]][nAncestors + 1L]
    nodeYi <- double(length(nAncestors))
    nodeYi[child[i, child[i, ] <= n_tip]] <- seq(treeYMargins[1], svgHeight-treeYMargins[2], len=n_tip)

    for (nodeI in rev(internal)) {
      nodeYi[nodeI] <- mean(nodeYi[Children(tree, nodeI)])
    }
    nodeY[[i]] <- round(nodeYi, 1)
  }
}
```
<script>
function onScreen(e) {
  var viewTop = $(window).scrollTop();
  var viewBottom = viewTop + ($(window).height());
  var elemTop = $(e).offset().top;
  return ((elemTop <= viewBottom) && (elemTop >= viewTop));
}

function highlightTaxon (e) {
  var target = e.target; // Which node triggered the click
  $target = $(target);
  if (target.nodeName === 'text') {
    taxonText = $(target).text();
    $withSameText = $('#reconstructions svg text:contains("' + taxonText + '")')
    if (localStorage.getItem(taxonText)) {
      localStorage.removeItem(taxonText)
      $withSameText.removeClass("highlightTaxon");
    } else {
      localStorage.setItem(taxonText, 1)
      $withSameText.addClass("highlightTaxon");
    }
  }
  return false;
}

function applyHighlighting () {
  if(localStorage.getItem($(this).text())) {
    $(this).addClass("highlightTaxon");
  }
  return false;
}

function updateVisible() {
  chosenTree = localStorage.getItem("chosenTree");
  $("svg.tree").each(function(index, item) {
    if (onScreen($(this))) {
      if ($(this).data('tree') != chosenTree) {        
        var oldTree = $(item);
        $.ajax({
           //url: "`r sprintf(fileNamer, '" + chosenTree + "', '" + $(oldTree).data("char") + "')`",
           url: "Brachiopod_phylogeny_files/figure-html/tree" + chosenTree + "-char" +
                $(oldTree).data("char") + ".svg",
          context: item,
          datatype: 'xml'
        }).done(function (newTree) {
          $(newTree).data('tree', chosenTree);
          $(newTree).click(highlightTaxon);
          $('text', newTree).each(applyHighlighting);
          $(this).replaceWith($('svg', newTree));
        })
      }
    }
  });
  return false;
}

function switchTree(input) {
  newValue = input.value * 1;
  if (!isNaN(newValue)) {
    newValue = Math.floor(newValue);
    newValue = Math.max(newValue, 1);
    newValue = Math.min(newValue, input.max);
    $("input.switcherNumber").val(newValue);
    localStorage.setItem("chosenTree", newValue);
    updateVisible()
  }
  return false;
}


$(document).ready(function() {
  window.$my = {
    trees : $("svg.tree")
  };

  // Produce switcher box by each SVG plot
  var originalSwitcher = $("div.switcher");
  $my.trees.each(function() {
      var thisTree = $(this);
      var switcherClone = originalSwitcher.clone().insertBefore(thisTree);
      $('input.switcherNumber', switcherClone).data("char", thisTree.data("char"));
    }
  );
  
  localStorage.setItem("chosenTree", originalSwitcher.val());
  $my.trees.click(highlightTaxon)
  $my.trees.data('tree', originalSwitcher.val());
  $('text', $my.trees).each(applyHighlighting)
  
  $('.book-body').scroll(updateVisible);

  originalSwitcher.remove();
  return false;
});
</script>
```{R character-mapping, echo=FALSE, fig.height=6.2, fig.width=7.1, results="asis"}
## These function definitions must be in the same block as when they are called.
Header <- function (level, content) paste0("  \n", paste0(rep('#', level), collapse=''), " ", content, "  \n")
PrintDivision <- function (parts) cat(Header(2L, paste(
  Italicize(this_char_parts[1:parts]), collapse=': ')))
PrintCharacter <- function () {
  cat(Header(3L, paste0("[", i, "] ", paste0(Italicize(
    this_char_parts[if(char_nesting[i] < 4) char_nesting[i] else 3:char_nesting[i]]),
    collapse=': '), " {-}")))
}
PrintSoloCharacter <- function () {
  cat(Header(2L, paste0(paste(
    Italicize(this_char_parts), collapse=': ')," [", i, "] ")))
}
DuplicateOf <- function (x) {
  duplicates <- duplicated(x)
  masters <- x[!duplicates]
  vapply(masters, function (d) x == d, logical(length(x)))
}
PrintStateNotes <- function (notes) {
  PrintThisNote <- function (note) {
    afflictedTaxa <- names(note)[note]
    master <- afflictedTaxa[1]
    cat(paste0("<div class='state-note' id='",
                     taxa_names[as.integer(master)], "-coding-", i,
                     "'>",
               paste(taxa_italic[as.integer(afflictedTaxa)], collapse=', '),
                      ": ", Italicize(notes[master]), "</div>  \n  \n"))
  }
  
  if (length(notes) > 0) {
    cat('  \n<div class="state-notes">')
  }
  if (length(notes) == 1) {
    onlyOne <- TRUE
    names(onlyOne) <- names(notes)
    PrintThisNote(onlyOne)
  } else {
    notes <- notes[order(taxa_sort[as.integer(names(notes))])]
    duplicates <- DuplicateOf(toupper(notes))
    apply(duplicates, 2, PrintThisNote)
  }
  if (length(notes) > 0) {
    cat('</div>  \n  \n')
  }
}

taxa_not_to_print <- '' # which(taxa_names %in% 'Namacalathus')
prev_char_parts <- "NONE"
prev_nesting <- 0

#for (i in 1:4) {
for (i in seq_len(n_char)) {
  
  this_char_parts <- char_parts[[i]]
  next_char_parts <- if (i == n_char) "LAST_CHARACTER" else char_parts[[i + 1L]]
  this_nesting <- char_nesting[i]
  next_nesting    <- if (i == n_char) 0 else char_nesting[i + 1L]
  
  if ( # Reasons to print a heading
    (this_char_parts[1] != prev_char_parts[1]) ||
    ( this_nesting > 1L && prev_nesting > 2L &&
      this_char_parts[2] != prev_char_parts[2]) ||
    ( this_nesting > 1L && prev_nesting > 1L && next_nesting > 2L &&
      this_char_parts[2] == next_char_parts[2] &&
      this_char_parts[2] != prev_char_parts[2])
  ) {
    if ( # Reasons to print a Solo character
      (this_char_parts[1] != next_char_parts[1] && 
       this_char_parts[1] != prev_char_parts[1]) ||
      (this_nesting == 2L && next_nesting > 1L &&
       prev_char_parts[1] == this_char_parts[1] &&
       next_char_parts[1] == this_char_parts[1]) ||
      (this_nesting == 1L && next_nesting > 1L &&
            next_char_parts[1] == this_char_parts[1]) ||
      prev_nesting > 2L && (
        next_nesting < 2L
        || (this_nesting > 1L && next_nesting > 2L && 
            (this_char_parts[2] != next_char_parts[2]))
      )
    ) {
      PrintSoloCharacter()
    }
    else if ( # Reasons to print a top-level heading
      this_nesting == 1 ||
      (next_nesting > 1 && (this_char_parts[2] != next_char_parts[2]))
    ) {
      PrintDivision(1)
      PrintCharacter()
    } else {
      PrintDivision(2)
      PrintCharacter()
    }
  } else { # Just print the character
    PrintCharacter()
  }
  prev_char_parts <- this_char_parts
  prev_nesting <- char_nesting[i]
  
  par(mar=rep(0.2, 4), cex=0.7)
  
  stateLabels <- my_states[[i]]
  my_chars_i <- my_chars[, i]
  
  if (knitr::is_html_output()) {
    for (treeNo in eachTree) {
      tree <- rootedTrees[[treeNo]]
      nodeXi <- nodeX[[treeNo]]
      nodeYi <- nodeY[[treeNo]]
      states_matrix <- apply.reconstruction(tree, my_chars_i)
      matrix_data <- MatrixData(states_matrix, state.labels=stateLabels)
      legendLabels <- matrix_data$legend
      legendCol <- matrix_data$legend_col
      edgeCol <- matrix_data$edge_col
      flagCol <- matrix_data$tips_colours
      tipFlag <- matrix_data$tips_labels
      nodeSupport <- round(SplitSupport(tree) / length(allTrees), 2)
      
      LineStyle <- function (x) ifelse(x == 'lightgrey', '" class="inapplicable', '')
      edges <- paste0(vapply(unique(edgeCol), function(colour) {
        theseEdges <- edgeCol == colour
        paste0('<path d="', paste0(
               'M', nodeXi[parent[treeNo, theseEdges]],
               ',', nodeYi[parent[treeNo, theseEdges]],
               'V', nodeYi[child[treeNo, theseEdges]],
               'H', nodeXi[child[treeNo, theseEdges]],
               collapse=''),
               '" stroke="', colour, LineStyle(colour), '"></path>')
      }, character(1)), collapse='')
      tips <- paste0('<text x="', (nodeXi[terminal] + 0L), 
                     '" y="', nodeYi[terminal] + textY,
                     '" fill="', flagCol[terminal],
                     '" class="flag">[', tipFlag[terminal], ']</text>',
                     '<text x="', (nodeXi[terminal] + 22L),
                     '" y="', nodeYi[terminal] + textY,
                     '" fill="', ifelse(flagCol %in% c('lightgrey', 'grey'), flagCol, '#111'),
                     '" class="taxonLabel">', 
                     gsub('_', ' ', tipLabel[treeNo, terminal], fixed=TRUE), '</text>',
                     collapse='')
      nodes <- paste0('<text x="', (nodeXi[internal] + 2L), 
                      '" y="', nodeYi[internal] + textY,
                      '" class="node" fill="', NodeColour(nodeSupport), 
                      '">', nodeSupport, '</text>', collapse='')
      nRegions <- length(states_matrix$regions)
      ciCaption <- paste0('<text x="', svgWidth - 4L,
                   '" y="', yStep + textY, '" text-anchor="end" class="stepsLabel">',
                    'Character adds <tspan class="score">', states_matrix$score,
                   '</tspan> to tree score</text><text x="', svgWidth - 4L,
                   '" y="', (yStep * 2) + textY, '" text-anchor="end" class="stepsLabel">',
                   '<tspan class="score">', nRegions,
                   '</tspan> additional region', ifelse(nRegions == 1, '', 's'), 
                   '</text><text x="', svgWidth - 4L,
                   '" y="', (yStep * 3) + textY, '" text-anchor="end" class="stepsLabel">',
                    ci_text[i, treeNo],
                   '</text><text x="', svgWidth - 4L,
                    '" y="', (yStep * 5) + textY, '" text-anchor="end" class="stepsLabel">',
                    '<tspan dy="16">An optimal tree under:</tspan>', 
                   paste0('<tspan x="', svgWidth - 2L,
                          '" style="font-style:italic" class="',
                          ifelse(analysisNames %in% treeNames[treeIndex==treeNo], 'this', 'notThis'),
                          'An" dy="1.2em">', analysisNames, '</tspan>', collapse=''),
                    '</text>')
        
                   
      
      svgSource <- paste0('<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="', 
                    svgWidth, '" height="', svgHeight, '" class="tree" data-char="', i, '">',
                    ciCaption, tips, edges, nodes,
                    '</svg>')
      write(svgSource, file=paste0('_book/', sprintf(fileNamer, treeNo, i)))
    }
    cat(svgSource)
  } else {
    plot.states.matrix(apply.reconstruction(trees[[1]], my_chars_i),
                       passes=0, counts=1:2, show.labels=1,
                       col.states=TRUE, state.labels=stateLabels,
                       use.edge.length=TRUE, legend.pos='topright')
    legend('bottomleft',  bty='n', ci_text[i, 1])
  
  }
  cat(paste0("  \n\n > **Character ", i, ": ", Italicize(char_names[i]), "**  \n>\n"))
  if (knitr::is_html_output()) {
    lineHeight <- 24L
    legendY <- round(lineHeight * seq_along(legendLabels), 1)
    cat(paste0('>  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="', svgWidth, 
        '" height="', lineHeight * length(legendLabels) + lineHeight - 5L, # For T/N statement
        '" class="statesLegend">',
        paste0('<path d="M0,', legendY - 15L, 'h22" stroke="', legendCol,
                       LineStyle(legendCol), '"></path>', collapse=''),
        '<text x="30" y="-10" class="legendLabels">', 
        paste0('<tspan x="30" dy="', lineHeight, '">', legendLabels, '</tspan>', collapse=''),
        '<tspan x=0 dy="', lineHeight, '">', 
        ifelse (IsTransformational(my_states[[i]]), "Transformational", "Neomorphic"),
        ' character.</tspan>',
        '</text></svg> \n>\n'))
  } else {
    PrintStates(Italicize(my_states[[i]]))
  }
  cat("  \n\n")
  char_notes_i <- char_notes[[i]]
  state_notes_i <- char_notes_i[[2]]
  state_notes_i <- state_notes_i[!names(state_notes_i) %in% taxa_not_to_print]
  if (length(char_notes_i[[1]]) > 0) cat(Italicize(char_notes_i[[1]]), "  \n")
  if (length(state_notes_i) > 0) PrintStateNotes(state_notes_i)
  cat("  \n") # Clear line, ready for next block
}
if (knitr::is_html_output()) {
  cat(paste0('<div class="switcher">',
    '<span class="selectTree">Tree number:</span>',
    '<input class="switcherNumber" type="number" min="1" max="',
    n_tree, '"  oninput="switchTree(this)" value="', n_tree, '"></input>',
    '</div>'))
}
```
