---
title: "Inapplicable data with the Fitch algorithm"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# Parsimony analysis {#treesearch}

The phylogenetic dataset contains a high proportion of inapplicable codings (404/3325 = 12% of tokens), which are known to introduce error and bias to phylogenetic reconstruction ([@Maddison1993;@Brazeau2018]).  As such, phylogenetic search employed a new algorithm that correctly handles inapplicable data [@Brazeau2018].  This algorithm is implemented in the _MorphyLib_ C library [@Brazeau2017Morphylib], and phylogenetic search was conducted using the _R_ package _TreeSearch_ v0.0.8 [@Smith2018TreeSearch].

## Search parameters

Heuristic searches were conducted using the parsimony ratchet [@Nixon1999] under equal and implied weights [@Goloboff1997] with a variety of concavity constants.  The consensus tree presented in the main manuscript represents a strict consensus of all trees that are most parsimonious under one or more of the concavity constants (_k_) 2, 3, 4.5, 7, 10.5, 16 and 24, an approach that is known to produce higher accuracy than equal weights at any fixed level of precision [@Smith2017].

## Analysis 

### Load data

_Namacalathus_ is included in the matrix but has been excluded from analysis due to its potentially long branch, which is likely to mislead analysis.

```{r TS Load morphoBank, echo=FALSE}
# Load most recent MorphoBank file
files <- list.files(pattern='mbank_X24932.*\\.nex', full.names=TRUE)
filename <- files[which.max(file.mtime(files))]

my_data <- ReadAsPhyDat(filename)
my_data$Namacalathus <- NULL # Exclude Namacalathus

iw_data <- PrepareDataIW(my_data)
```

### Generate starting tree

_Dailyatia_ is used as an outgroup.

```{R Starting tree, cache=TRUE}
nj.tree <- NJTree(my_data)
rooted.tree <- EnforceOutgroup(nj.tree, 'Dailyatia')
start.tree <- TreeSearch(tree=rooted.tree, dataset=my_data, maxIter=3000,
                         EdgeSwapper=RootedNNISwap, verbosity=0)
```

### Implied weights analysis

```{r Implied weights analysis in TreeSearch, cache=TRUE}
for (k in c(2, 3, 4.5, 7, 10.5, 16, 24)) {
  iw.tree <- IWRatchet(start.tree, iw_data, concavity=k,
                       ratchHits = 60, searchHits=55,
                       swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap),
                       verbosity=0)
  score <- IWScore(iw.tree, iw_data, concavity=k)
  # Write search results
  write.nexus(iw.tree, file=paste0("/TreeSearch/hy_k", k, "_", signif(score, 5), ".tre", collapse=''))

  suboptFraction = 0.02
  iw.consensus <- IWRatchetConsensus(iw.tree, iw_data, concavity=k,
                  swappers=list(RootedTBRSwap, RootedNNISwap),
                  searchHits=4,
                  suboptimal=score * suboptFraction,
                  nSearch=150, verbosity=0L)
  write.nexus(iw.consensus, file=paste0("../Hyoliths/hy_iw_k", k, "_", signif(IWScore(iw.tree, iw_data, concavity=k), 3), ".con.tre", collapse=''))
}
```

### Equal weights analysis

```{r Equal weights, cache=TRUE}
ew.tree <- Ratchet(start.tree, my_data, verbosity=0,
                   ratchHits = 60, searchHits=55,
                   swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap)))
write.nexus(best.tree, file=paste0("hy_ew_", Fitch(best.tree, my_data), ".nex", collapse=''))

ew.consensus <- RatchetConsensus(best.tree, my_data, nSearch=150,
                                 swappers=list(RootedTBRSwap, RootedNNISwap),
                                 verbosityl=0L)
write.nexus(ew.consensus, file=paste0("../Hyoliths/hy_ew_", Fitch(ew.tree, my_data), ".con.tre", collapse=''))
```

## Results


