--- 
title: "Brachiopod origins -- Supplementary material -- Phylogenetic analysis"
author: "Sun, Hai-Jing; Smith, Martin Ross; Zhu, Mao-Yan; Zeng, Han; Zhao, Fang-Chen"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [References.bib, MorphoBank.bib]
csl: http://raw.githubusercontent.com/citation-style-language/styles/master/paleobiology.csl
link-citations: yes
github-repo: ms609/hy
description: "Results of phylogenetic analysis"
---

```{r setup-index, include=FALSE}
set.seed(0)
knitr::opts_chunk$set(echo = TRUE)
library('TreeSearch'); library('ape'); library('phangorn')
files <- list.files(pattern='mbank_.*\\.nex', full.names=TRUE)
filename <- files[which.max(file.mtime(files))]
my_data <- ReadAsPhyDat(filename)
my_chars <- ReadCharacters(filename)
my_states <- attr(my_chars, 'state.labels')
my_chars <- my_chars[-1, ]
neomorphic <- vapply(my_states, function(x) !x[[1]] %in% c("", "''"), logical(1))
setPar <- function() par(mar=rep(0.2, 4), cex=0.8)

outgroup <- 'Dailyatia'

pal <- TreeSearch::brewer[[11]]

tipCol <- c(
  Namacalathus                    = pal[1],
  Novocrania                      = pal[4],
  Craniops                        = pal[4],
  Ussunia                         = pal[4],
  Gasconsia                       = pal[4],
  Heliomedusa_orienta             = pal[3],
  Heliomedusa                     = pal[3],
  Micrina                         = pal[3],
  Mickwitzia_muralensis           = pal[3],
  Mickwitzia                      = pal[3],
  Micromitra                      = pal[8],
  Askepasma_toddense              = pal[8],
  Askepasma                       = pal[8],
  Pelagodiscus_atlanticus         = pal[6],
  Pelagodiscus                    = pal[6],
  Mummpikia_nuda                  = pal[5],
  Mummpikia                       = pal[5],
  Lingula                         = pal[5],
  Eoobolus                        = pal[5],
  Botsfordia                      = pal[5],
  Siphonobolus_priscus            = pal[5],
  Siphonobolus                    = pal[5],
  Clupeafumosus_socialis          = pal[5],
  Clupeafumosus                   = pal[5],
  Lingulellotreta_malongensis     = pal[5],
  Lingulellotreta                 = pal[5],
  Acanthotretella                 = pal[5],
  Lingulosacculus                 = 'grey',
  Phoronis                        = pal[2],
  Dailyatia                       = pal[1],
  Eccentrotheca                   = pal[1],
  Yuganotheca_elegans             = 'grey',
  Yuganotheca                     = 'grey',
  Longtancunella_chengjiangensis  = 'grey',
  Longtancunella                  = 'grey',
  Paterimitra                     = pal[1],
  Pedunculotheca_diania           = 'black',
  Pedunculotheca                  = 'black',
  Haplophrentis_carinatus         = 'black',
  Haplophrentis                   = 'black',
  Tomteluva_perturbata            = 'grey',
  Tomteluva                       = 'grey',
  Salanygolina                    = pal[9],
  Coolinia_pecten                 = pal[9],
  Coolinia                        = pal[9],
  Antigonambonites_planus         = pal[9],
  Antigonambonites                = pal[9],
  Kutorgina_chengjiangensis       = pal[10],
  Kutorgina                       = pal[10],
  Nisusia_sulcata                 = pal[10],
  Nisusia                         = pal[10],
  Alisina                         = pal[11],
  Glyptoria                       = pal[11],
  Orthis                          = pal[11],
  Terebratulina                   = pal[11])


ColPlot <- function (tree) {
  setPar()
  plot(tree, tip.color = tipCol[tree$tip.label], lwd=2)
}
ColMissing <- function (omit) MarkMissing(omit, text.font=3, cex=0.8,
                                          text.col=tipCol[omit])
```
```{R Morphobank bibliography, echo=FALSE}
mbBib <- list.files(pattern='morphobank_bibliography.*\\.txt', full.names=TRUE)
mbRecent <- mbBib[which.max(file.mtime(mbBib))]
refs <- as.matrix(read.delim(mbRecent, sep="\t", header=TRUE, skip=1, row.names=NULL))
FirstWord <- function (text) gsub("^(\\w+).*$", "\\1", trimws(text), perl=TRUE)
FirstWords <- function (text) gsub("^\\W*(\\w+)\\W*(\\w+)?.*", "\\1\\2", trimws(text), perl=TRUE)
FormatAuthors <- function (text) {
  authors <- trimws(strsplit(text, ';')[[1]])
  names.pattern <- "(\\w+,)\\s(.*)"
  surnames <-  gsub(names.pattern, "\\1 ", authors)
  forenames <- gsub(names.pattern, "\\2", authors)
  forenames <- gsub("(\\w)\\w+\\.?", "\\1.", forenames)
  forenames <- gsub("\\.(\\w)", ". \\1", forenames)
  
  # Return:
  paste0(surnames, forenames, collapse=' and ')
}
RefKey <- function (ref) paste0(FirstWord(ref['Author']),
                                trimws(ref['Year']),
                                FirstWords(ref['Title']))
BibEntry <- function (ref) {
  BibLine <- function (bibKey, key, text=ref[key]) {
    if (is.na(ref[key]) || ref[key] == "") "" else  paste0("  ", bibKey, " = {", trimws(text), "},\n")
  }
  refType <- tolower(FirstWord(ref['Reference.Type']))
  if (refType %in% c('generic', 'journal')) refType <- 'article'
  paste0("@", refType, '{', 
         RefKey(ref), ",\n",
         BibLine('author', 'Author', FormatAuthors(ref['Author'])),
         BibLine('doi', 'DOI'),
         BibLine('journal', 'Secondary.Title'),
         BibLine('title', 'Title', paste0('{', gsub("</?i>", "_", ref["Title"], perl=TRUE), '}')),
         BibLine('number', 'Number'),
         BibLine('pages', 'Pages', gsub("\\-+", "--", ref["Pages"], perl=TRUE)),
         BibLine('volume', "Volume"),
         BibLine('year', 'Year'),
         "}\n"
         )
}

bibFile <- file("MorphoBank.bib", encoding='UTF-8')
writeLines(apply(refs, 1, BibEntry), bibFile)
close(bibFile)
refKeys <- apply(refs, 1, RefKey)
```

# Brachiopod origins {-}

This document provides a detailed discussion of analyses of the [morphological dataset](#dataset) constructed to accompany Sun _et al._ [-@Sun2018], and their results.

We first discuss the results presented in the main paper, which employ the algorithm described by Brazeau, Guillerme and Smith [-@Brazeau2018] for correct handling of inapplicable data in a parsimony setting, and explore how each
character is [reconstructed](#reconstructions) on an optimal tree.

For completeness, we also document the results of [standard Fitch parsimony](#tnt) analysis, and the results of [Bayesian analysis](#MrBayes), neither of which treat inapplicable data in a logically consistent fashion.

<!--chapter:end:index.Rmd-->

---
title: "Phylogenetic dataset"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# The dataset

Analysis was performed on a new matrix of `r length(names(my_data)) - 1L` early brachiozoan taxa, including hyoliths, tommotiids and mickwitziids, which were coded for `r sum(attr(my_data, 'weight'))` morphological characters (`r sum(neomorphic)` neomorphic, `r sum(!neomorphic)` transformational).

We incorporated _Namacalathus_ in the matrix, but preliminiary results did not uphold the homology of potentially brachiozoan-like features.  As such, we excluded it from our analysis due to its potentially long branch, which is likely to mislead analysis.

_Dailyatia_ was instead selected as an outgroup as camenellans have been interpreted as the earliest diverging members of the Brachiozoa [@Skovsted2015;@Zhao2017].

Characters are coded following the recommendations of Brazeau, Guillerme and
Smith [@Brazeau2018]:

- We have employed reductive coding, using a distinct state to mark character inapplicability. Character specifications follow the model of Sereno [-@Sereno2007].

- We have distinguished between neomorphic and transformational characters [sensu @Sereno2007] by reserving the token `0` to refer to the absence of a neomorphic character.  The states of transformational characters are represented by the tokens `1`, `2`, `3`, ...

- We code the absence of neomorphic ontologically dependent characters [sensu @Vogt2017] as absence, rather than inapplicability.


The complete dataset can be viewed and downloaded at Morphobank ([project 2800](https://morphobank.org/permalink/?P2800)), where each character is defined
and its coding for each taxon discussed.

<!--chapter:end:01_Dataset.Rmd-->

---
title: "TreeSearch results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Parsimony analysis {#treesearch}

The phylogenetic dataset contains a high proportion of inapplicable codings (`r sum(my_chars == '-')`/`r length(my_chars)` = `r round(sum(my_chars == '-') / length(my_chars), 3) * 100`% of tokens), which are known to introduce error and bias to phylogenetic reconstruction when the Fitch algorithm is employed [@Maddison1993;@Brazeau2018].  As such, we employed a new tree-scoring algorithm that correctly handles inapplicable data [@Brazeau2018], implemented in the _MorphyLib_ _C_ library [@Brazeau2017Morphylib].  We employed the _R_ package _TreeSearch_ v0.1.2 [@Smith2018TreeSearch] to conduct phylogenetic tree search with this algorithm.

## Search parameters

Heuristic searches were conducted using the parsimony ratchet [@Nixon1999] under equal and implied weights [@Goloboff1997].  The consensus tree presented in the main manuscript represents a strict consensus of all trees that are most parsimonious under one or more of the concavity constants (_k_) 2, 3, 4.5, 7, 10.5, 16 and 24, an approach that has been shown to produce higher accuracy than equal weights at any given level of precision [@Smith2017].

## Analysis 

The R commands used to conduct the analysis are reproduced below.
The results can most readily be replicated using the <mark>[R markdown files](https://@@@.@@@/)</mark> used 
to generate these pages.

### Initialize and load data

```{r treesearch-load-morphoBank, echo=TRUE}
kValues <- c(2, 3, 4.5, 7, 10.5, 16, 24)

# Load file from MorphoBank
my_data <- ReadAsPhyDat(filename)
my_data$Namacalathus <- NULL # Exclude Namacalathus
iw_data <- PrepareDataIW(my_data)
```

### Generate starting tree

Start from a neighbour-joining tree, rooted on the outgroup.

```{R treesearch-starting-tree}
nj.tree <- NJTree(my_data)
rooted.tree <- EnforceOutgroup(nj.tree, outgroup)
start.tree <- TreeSearch(tree=rooted.tree, dataset=my_data, maxIter=3000,
                         EdgeSwapper=RootedNNISwap, verbosity=0)
```

### Implied weights analysis

The position of the root does not affect tree score, so keep it fixed (using `RootedXXXSwap` functions) to avoid unnecessary swaps.

```{r treesearch-implied-weights-analysis, echo=TRUE, eval=FALSE}
for (k in kValues) {
  iw.tree <- IWRatchet(start.tree, iw_data, concavity=k,
                       ratchHits = 60, searchHits=55,
                       swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap),
                       verbosity=0L)
  score <- IWScore(iw.tree, iw_data, concavity=k)
  # Write single best tree
  write.nexus(iw.tree,
              file=paste0("TreeSearch/hy_iw_k", k, "_", 
                          signif(score, 5), ".nex", collapse=''))

  suboptFraction = 0.02
  iw.consensus <- IWRatchetConsensus(iw.tree, iw_data, concavity=k,
                  swappers=list(RootedTBRSwap, RootedNNISwap),
                  searchHits=4,
                  suboptimal=score * suboptFraction,
                  nSearch=150, verbosity=0L)
  write.nexus(iw.consensus, 
              file=paste0("TreeSearch/hy_iw_k", k, "_", 
                          signif(IWScore(iw.tree, iw_data, concavity=k), 5),
                          ".all.nex", collapse=''))
}
```

### Equal weights analysis

```{r treesearch-equal-weights-analysis, echo=TRUE, eval=FALSE}
ew.tree <- Ratchet(start.tree, my_data, verbosity=0L,
                   ratchHits = 10, searchHits=55,
                   swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap))
write.nexus(ew.tree, file=paste0(collapse='', "TreeSearch/hy_ew_",
                                 Fitch(ew.tree, my_data), ".nex"))

ew.consensus <- RatchetConsensus(ew.tree, my_data, nSearch=150,
                                 swappers=list(RootedTBRSwap, RootedNNISwap),
                                 verbosity=0L)
write.nexus(ew.consensus, file=paste0(collapse='', "TreeSearch/hy_ew_",
                                      Fitch(ew.tree, my_data), ".nex"))
```

## Results

### Implied weights results

```{R treesearch-load-iw-trees, echo=FALSE}
# Read results from files
iw.trees <- lapply(kValues, function (k) {
  iw.best <- list.files('TreeSearch', 
                      pattern=paste0('hy_iw_k',
                                     gsub('\\.', '\\\\.', k),
                                     '_\\d+\\.?\\d*\\.all\\.nex'),
                      full.names=TRUE)
  # Return:
  if (length(iw.best) == 0) {
    list()
  } else {
    read.nexus(iw.best[which.max(file.mtime(iw.best))])
  }
})
```

Wildcard taxa have been excluded from the consensus tree shown above to improve resolution.

```{r treesearch-iw-consensus, fig.cap="Consensus of implied weights analyses at all values of k", fig.width=6, fig.height=5, echo=FALSE}
omit = c("Micrina", 'Mickwitzia_muralensis',
#omit=c(lon, 'Clupeafumosus_socialis',
       'Heliomedusa_orienta')
ColPlot(ConsensusWithout(lapply(iw.trees, consensus), omit))
ColMissing(omit)
```



```{r treesearch-all-iw-results, fig.width=7.1, fig.height=4, echo=FALSE}
# Plot consensus results
par(mfrow=c(1, 2), mar=rep(0.2, 4))

ColPlot(consensus(lapply(iw.trees, consensus)))
text(-0.5, 1, pos=4, "Consensus of all k values", cex=0.8)

# Plot results for each value of k
PlotPanel <- function (i) {
  ColPlot(consensus(iw.trees[[i]]))
  text(1, 1, paste0('k = ', kValues[i]), pos=4)
}

PlotPanel(1)
```
```{R treesearch-iw-results-2, fig.width=7.1, fig.height=4, echo=FALSE}
par(mfrow=c(1, 2), mar=rep(0.2, 4))
PlotPanel(2)
PlotPanel(3)
```
```{R treesearch-iw-results-3, fig.width=7.1, fig.height=4, echo=FALSE}
par(mfrow=c(1, 2), mar=rep(0.2, 4))
PlotPanel(4)
PlotPanel(5)
```
```{R treesearch-iw-results-4, fig.width=7.1, fig.height=4, fig.cap="Implied weights results", echo=FALSE}
par(mfrow=c(1, 2), mar=rep(0.2, 4))
PlotPanel(6)
PlotPanel(7)
```

### Equal weights results

```{r treesearch-equal-weights-results, fig.cap="Strict consensus of equal weights results", echo=FALSE}
ew.best <- list.files('TreeSearch', pattern='hy_ew_\\d*\\.nex', full.names=TRUE)
ew.trees <- read.nexus(file=ew.best[which.max(file.mtime(ew.best))])
ColPlot(consensus(ew.trees))
```

```{R treesearch-equal-weights-pruned-consensus, fig.cap="Strict consensus of equal weights results, taxa excluded", echo=FALSE, eval=FALSE}
# omit <- c("none")
# ColPlot(ConsensusWithout(ew.tree, omit))
# ColMissing(omit)
```

<!--chapter:end:02_TreeSearch.Rmd-->

---
title: "Visualizing characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Character reconstructions {#reconstructions}

This page provides definitions for each of the characters in our matrix, and justifies codings in particular taxa where relevant.  Citations for all codings can be found by browsing the [morphological dataset](#dataset) on MorphoBank ([project 2800](https://morphobank.org/permalink/?P2800)).

```{R char loading functions, echo=FALSE}
StrReplace <- stringi::stri_replace_all_fixed

LookUpReference <- function (keys, original, prefix='', suffix='') {
  keyParts <- "^~~~(.+?)(\\b.*)~~~$"
  keySuffixes <- gsub(keyParts, "\\2", keys, perl=TRUE)
  keys <- gsub(keyParts, "\\1", keys, perl=TRUE)
  if (length(keys) == 0) {
    return (character(0))
  } else if (length(keys) == 1) {
    matches <- grepl(keys, refKeys, fixed=TRUE)
    if (sum(matches) == 1) {
      paste0(prefix, refKeys[matches], keySuffixes, suffix)
    } else {
      paste0('<mark>', original, '</mark>')
    }
  } else { # length(keys) > 1
     # initialize
    ret <- paste0('<mark>', original, '</mark>')
    if (length(suffix) == 1) suffix <- rep(suffix, length(keys))
    if (length(prefix) == 1) prefix <- rep(prefix, length(keys))
    
    matches <- vapply(keys, FUN=grepl, FUN.VALUE=logical(length(refKeys)), refKeys, fixed=TRUE)
    uniques <- colSums(matches) == 1
    ret[uniques] <- vapply(which(uniques), function (i) 
      paste0(prefix[i], refKeys[matches[, i]], keySuffixes[i], suffix[i])
      , character(1))
    
    # Return:
    ret
  }
}

ConvertReferences <- function (string) {
  noParentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)? (\\d\\d\\d\\d\\w?)\\b"
  ReplNoPar <- function (keyedText, oldKey, original) {
    StrReplace(keyedText, oldKey,
                LookUpReference(oldKey, original, prefix='@'),
               vectorize_all=FALSE)
  }
  
  parentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)? \\((\\d\\d\\d\\d\\w?)\\b([^\\)]*)\\)"
  ReplPar <- function (keyedText, oldKey, original) {
    StrReplace(keyedText, oldKey,
                LookUpReference(oldKey, original, 
                  prefix=paste0(gsub(parentheses, "\\1\\2", original, perl=TRUE), ' [-@'),
                  suffix=']'
                ), vectorize_all=FALSE)
                
  }
  
  ReplaceRefs <- function (pattern, strings, Replace) {
    execResults <- gregexpr(pattern, strings, perl=TRUE)
    matchText <- lapply(regmatches(strings, execResults), unique)
    keyed <- gsub(pattern, "~~~\\1\\3\\4~~~", strings, perl=TRUE)
    keys <- lapply(matchText, function (citation) {
      ret <- gsub(pattern, "~~~\\1\\3\\4~~~", citation, perl=TRUE)
      duplicates <- ret[duplicated(ret)]
      substr(ret[duplicated(ret)], nchar(duplicates)-6, nchar(duplicates)-3) <- '!x2!'
      ret
    })
    toEdit <- which(vapply(keys, length, 0) > 0)
    strings[toEdit] <- vapply(toEdit, function (i) {
      Replace(keyed[i], keys[[i]], matchText[[i]])
    }, character(1))
    # Return:
    strings
  }
  
  matches <- grepl(noParentheses, string)
  string[matches] <- ReplaceRefs(noParentheses, string[matches], ReplNoPar)
  
  matches <- grepl(parentheses, string)
  string[matches] <- ReplaceRefs(parentheses, string[matches], ReplPar)
  
  string <- gsub("\\(([^\\)]*?@\\S+?[^\\)]*)\\)", "[\\1]", string, perl=TRUE)
  
  # Return:
  string
}

MorphoBankDecode <- function (string) {
  string <- gsub("^n", "  \n", string, fixed=TRUE)
  string <- gsub("''", "'", string, fixed=TRUE)
  string <- gsub(" - ", " -- ", string, fixed=TRUE)
  string <- gsub("(\\d)\\-(\\d)", "\\1--\\2", string, perl=TRUE)
  string <- gsub("(\\d) ?um\\b", "\\1 &mu;m", string, perl=TRUE)
  string <- gsub(" et al ", " et al. ", string, fixed=TRUE)
  string <- gsub(" et alia", " et al.", string, fixed=TRUE)
  
  # Return:
  ConvertReferences(string)
}

EndSentence <- function (string) {
  ret <- gsub("\\s*\\.?\\s*\\.$", ".", paste0(string, '.'), perl=TRUE)
  ret <- gsub("(\\.[\"'])\\.$", "\\1", ret, perl=TRUE)
}

ReadNotes <- function (filepath) {
  lines <- readLines(filepath)
  charNote.pattern <- "^\\s+TEXT\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  stateNote.pattern <- "^\\s+TEXT\\s+TAXON=(\\d+)\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  upperLines <- toupper(lines)
  notesStart <- which(upperLines == "BEGIN NOTES;")
  endBlocks <- which(upperLines == "ENDBLOCK;")
  if (length(notesStart) == 0) {
    return(list("NOTES block not found in Nexus file."))
  } else if (length(notesStart) > 1) {
    return(list("Multiple NOTES blocks found in Nexus file."))
  } else {
    notesEnd <- endBlocks[endBlocks > notesStart][1] - 1L
    notesLines <- lines[(notesStart + 1):notesEnd]
    charNote.matches <- grepl(charNote.pattern, notesLines, perl=TRUE)
    charNotes <- gsub(charNote.pattern, "\\2",
                       notesLines[charNote.matches], perl=TRUE)
    charNotes <- EndSentence(MorphoBankDecode(charNotes))
    charNumbers <- gsub(charNote.pattern, "\\1",
                              notesLines[charNote.matches], perl=TRUE)
    
    stateNote.matches <- grepl(stateNote.pattern, notesLines, perl=TRUE)
    stateNotes <- gsub(stateNote.pattern, "\\3",
                       notesLines[stateNote.matches], perl=TRUE)
    stateNotes <- EndSentence(MorphoBankDecode(stateNotes))
    stateTaxon <- gsub(stateNote.pattern, "\\1",
                              notesLines[stateNote.matches], perl=TRUE)
    stateChar  <- gsub(stateNote.pattern, "\\2",
                              notesLines[stateNote.matches], perl=TRUE)
    
    charNotes <- lapply(seq_len(max(c(stateChar, charNumbers))), function (i) {
      ret <- list(
        charNotes[charNumbers == i],
        stateNotes[stateChar == i])
      names(ret[[2]]) <- stateTaxon[stateChar == i]
      
      # Return:
      ret
    })
    names(charNotes) <- charNumbers
    
    # Return:
    charNotes
  }
}

PrintStates <- function (states) {
  states <- gsub("^'(.*)'$", "\\1", states)
  tokens <- seq_along(states) - 1L
  if (states[1] == "") {
    states <- states[-1]
    tokens <- tokens[-1]
    transformational <- TRUE
  } else {
    transformational <- FALSE
  }
  cat(paste0(" > ", tokens, ": ", states, "  \n"))
  cat("> ", if (transformational) "Transformational" else "Neomorphic", "character.  \n>\n")
}


Italicize <- function (string) {
  string <- gsub(paste0("\\b(", 
                        paste0(gsub("_", "|", fixed = TRUE,
                                    c(taxa_names,
                                      'Bethia', 'Eichwaldia', 'Eoorthis',
                                      'Hadrotreta', 'Lochkothele', 'Neocrania',
                                      'Paracraniops', 'Paramicrocornus',
                                      'comleyensis', 'decaius',
                                      'vascula', 'genitalia','lateralia',
                                      'media', 'myaria', 'terminalia',
                                      'et al\\.', 'et al', 'sensu')),
                               collapse='|'),
              ")\\b"), "_\\1_", string, perl=TRUE, ignore.case=FALSE)
  gsub("\\b([A-Z]\\.) _([a-z])", "_\\1 \\2", string, perl=TRUE)
}
```
```{R load-the-characters, echo=FALSE}
library('Inapp')
tree <- iw.trees[[3]][[1]]
tree$edge.length <- rep(1, nrow(tree$edge))

char_names <- gsub("^'(.+)'$", "\\1", colnames(my_chars))
n_char <- ncol(my_chars)
char_parts <- strsplit(char_names, ": ")
char_nesting <- vapply(char_parts, length, 0L)
char_notes <- ReadNotes(filename)
taxa_names <- c("Namacalathus", rownames(my_chars))
taxa_plaintext <- gsub("_", " ", taxa_names, fixed=TRUE)
taxa_italic <- paste0("_", taxa_plaintext, "_")
#treeCol <- tipCol[tree$tip.label]
```

The _Inapp_ _R_ package [@Brazeau2018] was used to map each character onto one of the most parsimonious trees (obtained under implied weighting, $k = 4.5$):

```{R print-character-functions, echo=FALSE}
Header <- function (level, content) paste0("  \n", paste0(rep('#', level), collapse=''), " ", content, "  \n")
PrintDivision <- function (parts) cat(Header(2L, paste(char_parts_i[1:parts],
                                                       collapse=': ')))
PrintCharacter <- function () {
  cat(Header(3L, paste0("[", i, "] ", 
                        paste0(char_parts_i[if(char_nesting[i] < 4) char_nesting[i] else 3:char_nesting[i]], collapse=': '), " {-}")))
}
PrintSoloCharacter <- function () {
  cat(Header(2L, paste0(paste(char_parts_i, collapse=': '),
                        " [", i, "] ")))
}
```
```{R character-mapping, echo=FALSE, fig.height=6.6, fig.width=7.1, results="asis"}
taxa_not_to_print <- which(taxa_names %in% 'Namacalathus')
for (i in seq_len(n_char)) {
  
  char_parts_i <- char_parts[[i]]
  if (i > 1) char_parts_last <- char_parts[[i - 1L]]
  
  if (char_nesting[i] == 1
      && (i == n_char || char_parts[[i + 1L]][1] != char_parts_i[1])) {
    PrintSoloCharacter()
  } else if (i == 1) {
    PrintDivision(1)
    PrintCharacter()
  } else if (char_parts_last[1L] != char_parts_i[1L]) {
    PrintDivision(2)
    PrintCharacter()
  } else if (length(char_parts_i) > 1L) {
    if (length(char_parts_last) < 2L) {
      PrintDivision(2)
      PrintCharacter()
    } else if (char_parts_last[2L] != char_parts_i[2L]) {
      if (char_nesting[i - 1L] > 2
          && (
            i == n_char
            || char_nesting[i + 1L] < 2
            || char_parts_i[2] != char_parts[[i + 1L]][2]
            )
          ) {
        PrintSoloCharacter()
      } else {
        if (char_nesting[i - 1L] > 2) {
          PrintDivision(2)
        }
        PrintCharacter()
      }
    } else {
      PrintCharacter()
    }
  } else {
    PrintCharacter()
  }

  
  par(mar=rep(0.2, 4), cex=0.7)
  
  plot.states.matrix(apply.reconstruction(tree, my_chars[, i]),
                     passes=0, counts=1:2, show.labels=1,
                     col.states=TRUE, state.labels=my_states[[i]],
                     #tip.col=treeCol, 
                     use.edge.length=TRUE, legend.pos='topright')
  
  cat(paste0("  \n\n **Character ", i, ": ", Italicize(char_names[i]), "**  \n\n"))
  PrintStates(Italicize(my_states[[i]]))
  cat("  \n\n")
  char_notes_i <- char_notes[[i]]
  state_notes_i <- char_notes_i[[2]]
  state_notes_i <- state_notes_i[!names(state_notes_i) %in% taxa_not_to_print]
  if (length(char_notes_i[[1]]) > 0) cat(Italicize(char_notes_i[[1]]), "  \n")
  if (length(state_notes_i) > 0) {
    cat("  \n", paste0("<div class='state-note'>", taxa_italic[as.integer(names(state_notes_i))],
                      ": ", Italicize(state_notes_i), "</div>  \n  \n"))
  }
  cat("  \n") # Clear line, ready for next block
}
```

<!--chapter:end:03_Characters.Rmd-->

---
title: "Standard (Fitch) parsimony results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Fitch parsimony {#tnt}

Parsimony search was conducted in TNT v1.5 [@Goloboff2016] using ratchet and tree drifting heuristics [@Goloboff1999;@Nixon1999], repeating the search until the optimal score had been hit by 1500 independent searches:

> xmult:rat10 drift10 hits 1500 level 4 chklevel 5;

Searches were conducted under equal weights and results saved to file:

> piwe-; xmult; <span class="comment">Conduct search with equal weighting</span>
>
> tsav \*TNT/ew.tre;sav;tsav/ <span class="comment">Save results to file</span>;
>
> keep 0; hold 10000; <span class="comment">Clear trees from memory</span>

Further searches were conducted under extended implied weighting [@Goloboff1997;@Goloboff2014], under the concavity constants 2, 3, 4.5, 7, 10.5, 16 and 24:

> xpiwe=; <span class="comment">Enable extended implied weighting</span>
>
> piwe=2; xmult; <span class="comment">Conduct analysis at k = 2</span>
>
> tsav \*TNT/xpiwe2.tre; sav; tsav/; <span class="comment">Save results to file</span>
> 
> keep 0; hold 10000; <span class="comment">Clear trees from memory</span>
>
> piwe=3; xmult; <span class="comment">Conduct analysis at k = 3</span>
>
> tsav \*TNT/xpiwe3.tre; sav ;tsav/; <span class="comment">Save results to file</span>

We acknowledge the Willi Hennig Society for their sponsorship of the TNT software.

```{R, echo=FALSE}
tntFiles <- list.files('TNT/', pattern='xpiwe.*\\.tre', full=TRUE)
filename <- tntFiles[1]
tnTrees <- lapply(tntFiles, ReadTntTree)
tnConsensi <- lapply(tnTrees, consensus)

plotPanel <- function (i) {
  ColPlot(tnConsensi[[i]])
  text(1, 0.5, paste('k =', kValues[i]), pos=4, cex=0.6)
}
```

## Implied weights

The consensus of all implied weights runs is not very well resolved. 
This lack of resolution is largely a product of a few wildcard taxa, particularly at $k = 4.5$, which obscures a consistent set of relationships between the remaining taxa:

```{R tnt-iw-consensus, echo=FALSE, fig.wid=7.1, fig.height=4}
par(mfrow=c(1, 2))
ColPlot(consensus(tnConsensi)) 
text(1, 0.5, 'Consensus of all k values', pos=4, cex=0.6)

plotPanel(1)
```
```{R tnt-iw-3-4.5, fig.width=7.1, fig.height=4, echo=FALSE}
par(mfrow=c(1, 2))
plotPanel(2)
plotPanel(3)
```

```{R tnt-iw-7-10.5, fig.width=7.1, fig.height=4, echo=FALSE}
par(mfrow=c(1, 2))
plotPanel(4)
plotPanel(5)
```

```{R tnt-iw-16-24, fig.width=7.1, fig.height=4, echo=FALSE}
par(mfrow=c(1, 2))
plotPanel(6)
plotPanel(7)
```

### Consensus without k = 4.5

Though there's no clear reason that a single concavity constant should give such different results to values both above and below it, the results with $k = 4.5$ are so strikingly different that it is instructive to create a consensus tree that excludes this case:

```{R tnt-consensus-selective, echo=FALSE, fig.cap="TNT implied weights consensus"}
omit=c("Micrina", "Mickwitzia_muralensis")
ColPlot(ConsensusWithout(tnConsensi[-3], omit))
ColMissing(omit)
```

### Consensus of all IW trees, without wildcards

Even with the anomalous results at $k = 4.5$, the essential relationships between most taxa are recovered under all weighting situations:

```{R tnt-pruned-consensus, echo=FALSE, fig.cap="TNT implied weights consensus"}
#omit <- c('Clupeafumosus_socialis', 'Micrina', 'Mickwitzia_muralensis', 'Paterimitra', 'Heliomedusa_orienta', 'Tomteluva_perturbata', 'Yuganotheca_elegans', 'Salanygolina', 'Gasconsia', 'Mummpikia_nuda')
omit <- c("Salanygolina", "Askepasma_toddense", "Micrina", "Mickwitzia_muralensis",
          "Tomteluva_perturbata", "Yuganotheca_elegans")
ColPlot(ConsensusWithout(tnConsensi, omit))
ColMissing(omit)
```

## Equal weights

```{R tnt-ew-consensus, echo=FALSE, fig.cap="TNT Equal weights consensus"}
tntEw <- list.files('TNT/', pattern='ew\\.tre', full=TRUE)
omit <- c("Micrina", "Mickwitzia_muralensis")
ColPlot(ConsensusWithout(ReadTntTree(tntEw), omit))
ColMissing(omit)
```

<!--chapter:end:04_TNT.Rmd-->

---
title: "Bayesian Analysis results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---


# Bayesian analysis

```{R mrbayes-ini, echo=FALSE, cache=TRUE}
files <- list.files('MrBayes', pattern='^hyo\\..*\\.t$', full.names=TRUE)

allTrees <- lapply(files, read.nexus)
nTrees <- length(allTrees[[1]])

postBurnin <- lapply(allTrees, function (x) x[ceiling(nTrees * 0.1):nTrees])
```

Bayesian search was conducted in MrBayes v3.2.6 [@Ronquist2012] using the Mk model [@Lewis2001] with gamma-distributed rate variation across characters:

> lset coding=variable rates=gamma;

Branch length was drawn from a dirichlet prior distribution, which is less informative than an exponential model [@Rannala2012], but requires a prior mean tree length within about two orders of magnitude of the true value [@Zhang2012]. To satisfy this latter criterion, we specified the prior mean tree length to be equal to the length of the most parsimonious tree under equal weights, using a Dirichlet prior with $α_T = 1$, $β_T = 1/($_equal weights tree length_$/$_number of characters_$)$, $α = c = 1$:

> prset brlenspr = unconstrained: gammadir(1, `r signif(attr(my_data, 'nr')/Fitch(ew.trees[[1]], my_data), 2)`, 1, 1);

Neomorphic and transformational characters [_sensu_ @Sereno2007] were allocated to two separate partitions whose proportion of invariant characters and gamma shape parameters were allowed to vary independently:

> charset Neomorphic = `r paste(which(neomorphic), collapse=' ')`;
>
> charset Transformational = `r paste(which(!neomorphic), collapse=' ')`;
>
>
> partition chartype = 2: Neomorphic, Transformational;
>
> set partition = chartype;
>
>
> unlink shape=(all) pinvar=(all);


Neomorphic characters were not assumed to have a symmetrical transition rate – that is, the probability of the absent → present transition was allowed to differ from that of the present → absent transition, being drawn from a uniform prior:

> prset applyto=(1) symdirihyperpr=fixed(1.0);

The rate of variation in neomorphic characters was also allowed to vary from that of transformational characters:

> prset applyto=(1) ratepr=variable;

_`r outgroup`_ was selected as an outgroup:

> outgroup `r outgroup`;

Four MrBayes runs were executed, each sampling eight chains for 5&nbsp;000&nbsp;000 generations, with samples taken every 500 generations.  The first 10% of samples were discarded as burn-in.

> mcmcp ngen=5000000 samplefreq=500 nruns=4 nchains=8 burninfrac=0.1;

A posterior tree topology was derived from the combined posterior sample of both runs.

```{R mrbayes-full-consensus, echo=FALSE, fig.cap="Bayesian analysis, posterior probability > 50%, all taxa"}
omit <- c("none")
 # 'Novocrania', 'Craniops', 'Ussunia', 'Gasconsia',
thinned <- c(lapply(postBurnin[[1]], drop.tip, omit),
             lapply(postBurnin[[2]], drop.tip, omit),
             lapply(postBurnin[[3]], drop.tip, omit),
             lapply(postBurnin[[4]], drop.tip, omit))
class(thinned) <- 'multiPhylo'
ColPlot(root(consensus(thinned, p=0.5), outgroup, resolve.root=TRUE))
#ColMissing(omit)
```

```{R mrbayes-pruned-consensus, echo=FALSE, fig.cap="Bayesian analysis, posterior probability > 50%, wildcard taxa pruned", cache=TRUE}
omit <- c(
  'Mickwitzia_muralensis', 'Heliomedusa_orienta', 'Micrina',
  'Craniops', 'Novocrania',
  'Yuganotheca_elegans', 'Tomteluva_perturbata', 
  'Nisusia_sulcata', 'Kutorgina_chengjiangensis'
  )
thinned <- c(lapply(postBurnin[[1]], drop.tip, omit),
             lapply(postBurnin[[2]], drop.tip, omit),
             lapply(postBurnin[[3]], drop.tip, omit),
             lapply(postBurnin[[4]], drop.tip, omit))
class(thinned) <- 'multiPhylo'
ColPlot(root(consensus(thinned, p=0.5), outgroup, resolve.root = TRUE))
ColMissing(omit)
```

Convergence was indicated by PSRF = 1.00 and an estimated sample size of > 1000 for each parameter:

```{R mrbayes-parameter-summary, fig.cap="MrBayes parameter summary", echo=FALSE, asis=TRUE, cache=TRUE}
knitr::kable(read.table ('MrBayes/hyo.nex.pstat', skip=1, header=TRUE),
             caption="MrBayes parameter estimates (.pstat file)")
```

It's interesting to note the position of _Gasconsia_, which is widely held to have an affinity with the craniid brachiopods, and is recovered in such a position using the inapplicable-safe parsimony algorithm (but not always when the standard Fitch parsimony algorithm is used). 

One possibility is that the failure of Bayesian analysis to recover this group as a clade reflects inappropriate handling of inapplicable data in the Mk model, though it is at present difficult to test this hypothesis.

<!--chapter:end:05_MrBayes.Rmd-->

---
title: "Taxonomic implications"
author: "Martin R. Smith"
---

# Taxonomic implications

This section briefly places key features of our results in the context of previous phylogenetic hypotheses.

Craniiforms
: Trimerellids are reconstructed as paraphyletic with respect to Craniiforms.  
: This is consistent with the affinity commonly drawn between these groups [e.g. @Williams2000BrachiopodaLinguliformea], and helps to account for the stratigraphically late (Ordovician) appearance of Craniids in the fossil record.  (Aragonite is underrepresented in early Palaeozoic strata due to taphonomic bias.)

Rhynchonelliforms
: The position of kutorginids in the brachiopod stem lineage has been tricky to resolve [@Holmer2018Theattachment]; we resolve them as paraphyletic with respect to Rhynconellata + Obolellata (represented by _Alisina_), which is broadly in accord to previous proposals [@Holmer2018Evolutionarysignificance].  Chileids form the adelphiotaxon to this clade.
:
: _Salanygolina_ has been interpreted as a stem-group rhynchonelliform based on its combination of paterinid and chileate features [@Holmer2009Theenigmatic].  Our results position _Salanygolina_ between paterinids and chileids, which directly corroborates this proposed phylogenetic position.  Basal rhynchonellids are characterized by a circular umbonal perforation in the ventral valve, associated with a colleplax.

Linguliforms
: The reconstruction of Linguloformea comprising Lingulids (including acrotretids and siphonotretids) as sister to the Discinids is as expected.
: More novel is the reconstruction of _Mummpikia_ in the linguliform total group: a rhynchonelliform affinity has been assumed based on its Its calcitic mineralogy.  
: This said, Balthasar [-@Balthasar2008iMummpikia] has highlighted the similarities between obolellids and linguliform brachiopods, including sub-&mu;m vertical canals and the detailed configuration of the posterior shell margin.
: Our analysis upholds the case for a linguliform affinity; a calcitic shell seemingly arose through an independent change within this taxon  As such, _Mummpikia_ has no direct bearing on the origin of 'Calciata', save that shell mineralogy is perhaps less static than commonly assumed.

Tommotiids
: Tommotiids represent a basal grade, paraphyletic to phoronids and crown-group brachiopods, in line with previous interpretations.  The tree is somewhat arbitrarily rooted on _Dailyatia_, so it is worth considering the possibility that the root lies elsewhere. 
: The position of _Micrina_ + _Mickwitzia_ is somewhat difficult to pin down; certain analytical configruations reconstruct then as stem-brachiopods; others place them closer to the discinids or the craniiforms.

Hyoliths
: Hyoliths are interpreted as stem-group Brachiopods, which refines the broader phylogenetic position proposed by Moysiuk _et al_. [-@Moysiuk2017Hyolithsare].  This is to say, they sit crownwards of phoronids, but no analysis places them within the Brachiopod crown group.
: Hyoliths are interpreted as derived tommotiids; their precise position varies based on analytical details, but they tend to plot close to _Paterimitra_.  They represent an early and potentially independent move to a closed filtration chamber within the Brachiopod lineage.  

_Yuganotheca_, _Tomteluva_, _Longtancunella_, Acrotretids
: The position of certain eccentric taxa is not robustly constrained; we opt not to hang too much on these results that are liable to change as additional data comes to light.  That said, it is notable that _Yuganotheca_ does consistently occur within the rhynchonelliform stem lineage, often in association with _Salanygolina_, suggesting that they represent aberrant offshoots of this lineage.  This places them within the brachiopod crown-group; a position in the stem lineage [@Zhang2014Anearly] is difficult to reconcile with the increasingly well-constrained nature rise of the brachiopods body plan.

<!--chapter:end:06_Implications.Rmd-->

---
title: "References"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

`r if (knitr::is_html_output()) '# References {-}'`

<!--chapter:end:99_References.Rmd-->

