---
title: "Standard (Fitch) parsimony results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Fitch parsimony {#fitch}

Parsimony search with the @Fitch1971 algorithm was conducted in TNT v1.5 [@Goloboff2016] using Ratchet and tree drifting heuristics [@Goloboff1999;@Nixon1999], repeating the search until the optimal score had been hit by 1500 independent searches:

> xmult:rat25 drift25 hits 1500 level 4 chklevel 5;

Searches were conducted under equal weights and results saved to file:

> piwe-; xmult; <span class="comment">/&#42; Conduct search with equal weighting &#42;/</span>
>
> tsav &#42;TNT/ew.tre;sav;tsav/; <span class="comment">/&#42; Save results to file &#42;/</span>
>

Node support was estimated by calculating the proportion of jackknife replicates in which each group occurred, using 5000 symmetric resampling iterations, following the recommendations of @Kopuchian2010 and @Simmons2011.

> var: nt; <span class="comment">/&#42; Define a variable to track tree address &#42;/</span>
>
> nelsen *; <span class="comment">/&#42; Generate strict consensus tree &#42;/</span>
>
> set nt ntrees; ttag=; <span class="comment">/&#42; Prepare for resampling &#42;/</span>
>
> resample=sym 5000 frequency from &#39;nt&#39;; <span class="comment">/&#42; Symmetric resampling, counting frequencies &#42;/</span>
>
> log TNT/ew.sym; ttag/; log/; <span class="comment">/&#42; Write results to log &#42;/</span>
>
> keep 0; ttag-; hold 10000; <span class="comment">/&#42; Clear memory &#42;/</span>

Further searches were conducted under extended implied weighting [@Goloboff1997;@Goloboff2014], under the concavity constants `r paste(kValues[-length(kValues)], collapse=', ')` and `r kValues[length(kValues)]`:

> xpiwe=; <span class="comment">/&#42; Enable extended implied weighting &#42;/</span>
>
> piwe=2; xmult; <span class="comment">/&#42; Conduct analysis at k = 2 &#42;/</span>
>
> tsav &#42;TNT/xpiwe2.tre; sav; tsav/; <span class="comment">/&#42; Save results to file &#42;/</span>
>
> nelsen *; set nt ntrees; ttag=; <span class="comment">/&#42; Prepare for resampling &#42;/</span>
>
> resample=frequency from &#39;nt&#39;; <span class="comment">/&#42; Symmetric resampling &#42;/</span>
>
> log TNT/ew.sym; ttag/; log/; <span class="comment">/&#42; Write results to log &#42;/</span>
> 
> keep 0; ttag-; hold 10000; <span class="comment">/&#42; Clear memory &#42;/</span>
>
> <span class="comment">/&#42; Repeat this block for each value of k &#42;/</span>

Results can be replicated by:

- Downloading `r paste0("[the data in TNT format](", tntLink, ")")`
`r if(!knitr::is_html_output()) paste0(": [", gsub("https?://", "", tntLink), "](", tntLink, ")")`.
- Saving [the script above](`r rawGit`tnt.run) to the same directory, with the filename `tnt.run`.
- Opening TNT, typing `piwe=` before you load the downloaded dataset (to enable extended implied weighting), then typing `tnt` into the command box to run the script.

We acknowledge the Willi Hennig Society for their sponsorship of the TNT software.

## Results

```{R tnt-results-init, echo=FALSE}
tnTrees <- lapply(tntFiles, ReadTntTree, relativePath='.', keepEnd=1)
tnTrees <- lapply(tnTrees, as.multiPhylo)
tnTrees <- lapply(tnTrees, function (x) lapply(x, drop.tip, ignored_taxa))
tnConsensi <- lapply(tnTrees, consensus)
tn3Consensi <- lapply(tnTrees[-1], consensus)
```

(ref:tnt-maj-cons) Majority-rule consensus of all trees that are optimal under $2 \leq k \leq 24$.

```{R tnt-iw-overview, echo=FALSE, fig.cap="(ref:tnt-maj-cons)"}
omit <- c("Micrina", "Micromitra",
          "Longtancunella_chengjiangensis",# "Yuganotheca_elegans",
          "Salanygolina", "Askepasma_toddense")#, "Tomteluva_perturbata")
majCon <- RootTree(ConsensusWithout(tnConsensi, omit, p=0.5), rootingTips)
ColPlot(majCon)
ColMissing(omit)

source('treeFunctions.R')
tnFlattened <- list()
for (i in seq_along(tnTrees)) {
  tnFlattened <- c(tnFlattened, tnTrees[[i]])
}
tnFlattened <- lapply(tnFlattened, drop.tip, omit)
tipIndex <- sort(tnFlattened[[1]]$tip.label)
tnSplits <- GetSplits(tnFlattened, tipIndex)

supporters <- SplitSupport(majCon, tnSplits, tipIndex)
nodelabels(paste0("\n\n", signif(supporters / length(tnFlattened), 3)),
           col=NodeColour(round(supporters / length(tnFlattened), 2), show1=FALSE),
           adj=0, pos=2, frame='none', cex=0.75)
```

(ref:tnt-no2-cons) Majority-rule consensus of all trees that are optimal under $3 \leq k \leq 24$.

```{R tnt-iw-nok2, echo=FALSE, fig.cap="(ref:tnt-no2-cons)"}
majCon <- RootTree(consensus(tn3Consensi, p=0.5), rootingTips)
ColPlot(majCon)

tnFlattened <- list()
for (i in seq_along(tnTrees)[-1]) {
  tnFlattened <- c(tnFlattened, tnTrees[[i]])
}
tipIndex <- sort(tnFlattened[[1]]$tip.label)
tnSplits <- GetSplits(tnFlattened, tipIndex)

supporters <- SplitSupport(majCon, tnSplits, tipIndex)
nodelabels(paste0("\n\n", signif(supporters / length(tnFlattened), 3)),
           col=NodeColour(round(supporters / length(tnFlattened), 2), show1=FALSE),
           adj=0, pos=2, frame='none', cex=0.75)
```

(ref:tnt-iw-results) Strict consensus of all trees recovered by TNT using Fitch parsimony with implied weighting

(ref:tnt-iw-explanation) The strict consensus of all implied weights runs is not very well resolved, largely due to an unusual optimal tree at $k = 2$, which obscures a consistent set of relationships between the remaining taxa.

```{R tnt-iw-consensus, fig.wid=7.1, fig.height=8, fig.cap="(ref:tnt-iw-results) (ref:first-panels) (ref:tnt-iw-explanation)", echo=FALSE}
par(mfrow=c(2, 2))
ColPlot(RootTree(consensus(tnConsensi), rootingTips))
text(1, 0.5, 'Consensus of all k values', pos=4, cex=0.6)

PlotPanel(tnConsensi, 1)
PlotPanel(tnConsensi, 2)
PlotPanel(tnConsensi, 3)
```

```{R tnt-iw-7-24, fig.width=7.1, fig.height=8, fig.cap="(ref:tnt-iw-results), (ref:second-panels)", echo=FALSE}
par(mfrow=c(2, 2))
PlotPanel(tnConsensi, 4)
PlotPanel(tnConsensi, 5)
PlotPanel(tnConsensi, 6)
PlotPanel(tnConsensi, 7)
```

<!--### Consensus of all IW trees, without wildcards

Even with the anomalous results at $k = 4.5$, the essential relationships between most taxa are recovered under all weighting situations:

```{R tnt-pruned-consensus, echo=FALSE, fig.cap="TNT implied weights consensus"}
#omit <- c('Clupeafumosus_socialis', 'Micrina', 'Mickwitzia_muralensis', 'Paterimitra', 'Heliomedusa_orienta', 'Tomteluva_perturbata', 'Yuganotheca_elegans', 'Salanygolina', 'Gasconsia', 'Mummpikia_nuda')
omit <- c("none")
ColPlot(ConsensusWithout(tnConsensi, omit))
ColMissing(omit)
```
-->
\newpage

(ref:tnt-ew-cons) Consensus of all trees obtained using equally weighted Fitch parsimony in TNT.  Nodes labelled with jackknife frequencies.

```{R tnt-ew-consensus, echo=FALSE, fig.cap="(ref:tnt-ew-cons)"}
# This function will be included in a future release of TreeSearch.
TNTText2Tree <- function (treeText) {
  treeText <- gsub("(\\d+)", "\\1,", treeText, perl = TRUE)
  treeText <- gsub(")(", "),(", treeText, fixed = TRUE)
  treeText <- gsub("*", ";", treeText, fixed = TRUE)
  # Return:
  read.tree(text = gsub(", )", ")", treeText, fixed = TRUE))
}

tntEw <- list.files('./TNT/', pattern='ew\\.tre', full=TRUE)
tntEwTrees <- ReadTntTree(tntEw, relativePath='.')
jackLines <- readLines('./TNT/ew.sym')
jackTree <- TNTText2Tree(jackLines[3])
jackTipOrder <- order(as.integer(jackTree$tip.label) + 1L)
jackNodeOrder <- unique(unlist(Ancestors(jackTree, jackTipOrder)))[-1]
nTntNode <- jackTree$Nnode

jackTree$tip.label <- tntEwTrees[[1]]$tip.label
jackScores <- trimws(gsub("ttag \\+\\d+ (.*); *", "\\1", jackLines[length(jackLines) - (nTntNode - 2L):0]))
jackFreq <- gsub("^(\\d+)/.*", "\\1", jackScores)
jackGC   <- gsub("^\\d+/(\\[?\\d+\\]?)$", "\\1", jackScores)
ColPlot(jackTree)
nodeScores <- as.integer(jackFreq[order(jackNodeOrder)])
nodelabels(paste0(c('', nodeScores), "\n"),
           col=c('black', NodeColour(nodeScores / 200L + 0.5, show1=FALSE)),
           adj=0, pos=2, frame='none', cex=0.75)

#omit <- c("Micrina", "Mickwitzia_muralensis")
#ColPlot(RootTree(ConsensusWithout(tntEwTrees, omit), rootingTips))
#ColMissing(omit)
```
