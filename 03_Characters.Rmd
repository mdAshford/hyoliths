---
title: "Visualizing characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib, MorphoBank.bib]
csl: http://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# Character reconstructions {#reconstructions}

```{R, echo=FALSE}
library('Inapp')
str_replace <- stringi::stri_replace_all_fixed
tree <- iw.trees[[3]][[1]]
tree$edge.length <- rep(1, nrow(tree$edge))

LookUpReference <- function (keys, original, Format) {
  keys <- gsub("~", "", keys, fixed=TRUE)
  if (length(keys) == 0) {
    return (character(0))
  } else if (length(keys) == 1) {
    matches <- grepl(keys, refKeys, fixed=TRUE)
    if (sum(matches) == 1) {
      Format(refKeys[matches], original)
    } else {
      original
    }
  } else {
    matches <- vapply(keys, FUN=grepl, FUN.VALUE=logical(length(refKeys)), refKeys, fixed=TRUE)
    ret <- original
    uniques <- colSums(matches) == 1
    ret[uniques] <- vapply(which(uniques), function (i) 
      Format(refKeys[matches[, i]], original[i]), character(1))
    
    # Return:
    ret
  }
}

ConvertReferences <- function (string) {
  noParentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)? (\\d\\d\\d\\d)"
  ReplNoPar <- function (keyedText, oldKey, original) {
    str_replace(keyedText, oldKey, 
                LookUpReference(oldKey, original, function(x, raw) paste0('@', x)),
                vectorize_all=FALSE)
  }
  
  parentheses <- "([A-Z][A-z]+)( et al\\.| ?& ?\\w+)? \\((\\d\\d\\d\\d)([^\\)]*)\\)"
  ReplPar <- function (keyedText, oldKey, original) {
    str_replace(keyedText, pattern=oldKey, replacement=
                LookUpReference(oldKey, original, function (x, raw)
                  paste0(gsub(parentheses, "\\1\\2", raw, perl=TRUE), ' [-@', x,
                  gsub(parentheses, "\\4", raw, perl=TRUE), ']')),
                vectorize_all=FALSE)
  }
  
  ReplaceRefs <- function (pattern, strings, Replace) {
    execResults <- gregexpr(pattern, strings, perl=TRUE)
    matchText <- lapply(regmatches(strings, execResults), unique)
    keyed <- gsub(pattern, "~~~\\1\\3~~~", strings, perl=TRUE)
    keys <- lapply(matchText, function (x) unique(gsub(pattern, "~~~\\1\\3~~~",
                                                       x, perl=TRUE)))
    toEdit <- which(vapply(keys, length, 0) > 0)
    strings[toEdit] <- vapply(toEdit, function (i) {
      Replace(keyed[i], keys[[i]], matchText[[i]])
    }, character(1))
    # Return:
    strings
  }
  
  matches <- grepl(noParentheses, string)
  string[matches] <- ReplaceRefs(noParentheses, string[matches], ReplNoPar)
  
  matches <- grepl(parentheses, string)
  string[matches] <- ReplaceRefs(parentheses, string[matches], ReplPar)
  
  string <- gsub("\\(([^\\)]+?@\\S+?[^\\)]*)\\)", "[\\1]", string, perl=TRUE)
  
  # Return:
  string
}

MorphoBankDecode <- function (string) {
  string <- gsub("^n", "  \n", string, fixed=TRUE)
  string <- gsub("''", "'", string, fixed=TRUE)
  string <- gsub(" - ", " -- ", string, fixed=TRUE)
  string <- gsub("(\\d)\\-(\\d)", "\\1--\\2", string, perl=TRUE)
  string <- gsub("(\\d) ?um\\b", "\\1 &mu;m", string, perl=TRUE)
  string <- gsub(" et al ", " et al. ", string, fixed=TRUE)
  string <- gsub(" et alia", " et al.", string, fixed=TRUE)
  
  # Return:
  ConvertReferences(string)
}

EndSentence <- function (string) gsub("\\s*\\.?\\s*\\.$", ".", paste0(string, '.'), perl=TRUE)

ReadNotes <- function (filepath) {
  lines <- readLines(filepath)
  charNote.pattern <- "^\\s+TEXT\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  stateNote.pattern <- "^\\s+TEXT\\s+TAXON=(\\d+)\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  upperLines <- toupper(lines)
  notesStart <- which(upperLines == "BEGIN NOTES;")
  endBlocks <- which(upperLines == "ENDBLOCK;")
  if (length(notesStart) == 0) {
    return(list("NOTES block not found in Nexus file."))
  } else if (length(notesStart) > 1) {
    return(list("Multiple NOTES blocks found in Nexus file."))
  } else {
    notesEnd <- endBlocks[endBlocks > notesStart][1] - 1L
    notesLines <- lines[(notesStart + 1):notesEnd]
    charNote.matches <- grepl(charNote.pattern, notesLines, perl=TRUE)
    charNotes <- gsub(charNote.pattern, "\\2",
                       notesLines[charNote.matches], perl=TRUE)
    charNotes <- EndSentence(MorphoBankDecode(charNotes))
    charNumbers <- gsub(charNote.pattern, "\\1",
                              notesLines[charNote.matches], perl=TRUE)
    
    stateNote.matches <- grepl(stateNote.pattern, notesLines, perl=TRUE)
    stateNotes <- gsub(stateNote.pattern, "\\3",
                       notesLines[stateNote.matches], perl=TRUE)
    stateNotes <- EndSentence(MorphoBankDecode(stateNotes))
    stateTaxon <- gsub(stateNote.pattern, "\\1",
                              notesLines[stateNote.matches], perl=TRUE)
    stateChar  <- gsub(stateNote.pattern, "\\2",
                              notesLines[stateNote.matches], perl=TRUE)
    
    charNotes <- lapply(seq_len(max(c(stateChar, charNumbers))), function (i) {
      ret <- list(
        charNotes[charNumbers == i],
        stateNotes[stateChar == i])
      names(ret[[2]]) <- stateTaxon[stateChar == i]
      
      # Return:
      ret
    })
    names(charNotes) <- charNumbers
    
    # Return:
    charNotes
  }
}

PrintStates <- function (states) {
  states <- gsub("^'(.*)'$", "\\1", states)
  tokens <- seq_along(states) - 1L
  if (states[1] == "") {
    states <- states[-1]
    tokens <- tokens[-1]
    transformational <- TRUE
  } else {
    transformational <- FALSE
  }
  cat(paste0(" > ", tokens, ": ", states, "  \n"))
  cat("> ", if (transformational) "Transformational" else "Neomorphic", " character.  \n>\n")
}

char_names <- gsub("^'(.+)'$", "\\1", colnames(my_chars))
char_notes <- ReadNotes(filename)
taxa_names <- c("Namacalathus", rownames(my_chars))
taxa_plaintext <- gsub("_", " ", taxa_names, fixed=TRUE)
taxa_italic <- paste0("_", taxa_plaintext, "_")
Italicize <- function (text) {
  gsub(paste0("\\b(", paste0(gsub("_", "|", c(taxa_names, 'Eoorthis', 'comleyensis', 'et al\\.', 'et al', "A\\. decaius"), fixed = TRUE), collapse='|'),
              ")\\b"), "_\\1_", text, perl=TRUE, ignore.case=TRUE)
}
#treeCol <- tipCol[tree$tip.label]
```

This page defines each characer and accounts for its coding in particular taxa.  Citations for all codings can be found by browsing the [morphological dataset](#dataset) on MorphoBank ([project 2800](https://morphobank.org/permalink/?P2800)).

The _Inapp_ _R_ package [@Brazeau2018] was used to map each character onto one of the most parsimonious trees (obtained under implied weighting, $k = 4.5$):


```{R, echo=FALSE, fig.height=6.6, fig.width=7.1, results="asis"}
for (i in seq_len(ncol(my_chars))) {
  cat("\n## ", char_names[i], " {-}  \n")
  
  par(mar=rep(0.2, 4), cex=0.7)
  
  plot.states.matrix(apply.reconstruction(tree, my_chars[, i]),
                     passes=0, counts=1:2, show.labels=1,
                     col.states=TRUE, state.labels=my_states[[i]],
                     #tip.col=treeCol, 
                     use.edge.length=TRUE, legend.pos='topright')
  
  cat("  \n\n **Character ", i, ": ", char_names[i], "**  \n\n")
  PrintStates(my_states[[i]])
  cat("  \n\n")
  char_notes_i <- char_notes[[i]]
  state_notes_i <- char_notes_i[[2]]
  if (length(char_notes_i[[1]]) > 0) cat(Italicize(char_notes_i[[1]]), "  \n")
  if (length(state_notes_i) > 0) {
    cat("  \n ", paste0(taxa_italic[as.integer(names(state_notes_i))],
                      ": ", Italicize(state_notes_i), "  \n  \n "))
  }
  cat("  \n") # Clear line, ready for next block
}
```
