---
title: "TreeSearch results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Parsimony analysis {#treesearch}

The phylogenetic dataset contains a considerable proportion of inapplicable codings (`r sum(my_chars == '-')`/`r length(my_chars)` = `r round(sum(my_chars == '-') / length(my_chars), 3) * 100`% of tokens), which are known to introduce error and bias to phylogenetic reconstruction when the Fitch algorithm is employed [@Maddison1993;@Brazeau2018].  As such, we employed a new tree-scoring algorithm that correctly handles inapplicable data [@Brazeau2018], implemented in the _MorphyLib_ C library [@Brazeau2017Morphylib].  We employed the R package _TreeSearch_ v0.1.2 [@Smith2018TreeSearch] to conduct phylogenetic tree search with this algorithm.

As this is a new method, we also employed the traditional, Fitch algorithm, even though this approach is known to generate erroneous trees.  The results of this analysis can be viewed in [a later section](#fitch).


## Search parameters

Heuristic searches were conducted using the parsimony ratchet [@Nixon1999] under equal and implied weights [@Goloboff1997].  The consensus tree presented in the main manuscript represents a strict consensus of all trees that are most parsimonious under one or more of the concavity constants (_k_) 2, 3, 4.5, 7, 10.5, 16 and 24, an approach that has been shown to produce higher accuracy (i.e. more nodes and quartets resolved correctly) than equal weights at any given level of precision [@Smith2017].

## Analysis 

The R commands used to conduct the analysis are reproduced below.
The results can most readily be replicated using the [R markdown files](https://github.com/ms609/hyoliths/) (.Rmd) used to generate these pages.

### Initialize and load data

```{r treesearch-load-morphoBank, echo=TRUE, eval=FALSE}
# Load data from locally downloaded copy of MorphoBank matrix
my_data <- ReadAsPhyDat(filename)
my_data[ignored_taxa] <- NULL
iw_data <- PrepareDataIW(my_data)
```

### Generate starting tree

Start by quickly rearranging a neighbour-joining tree, rooted on the outgroup.

```{R treesearch-starting-tree, echo=TRUE}
nj.tree <- NJTree(my_data)
rooted.tree <- EnforceOutgroup(nj.tree, outgroup)
start.tree <- TreeSearch(tree=rooted.tree, dataset=my_data, maxIter=3000,
                         EdgeSwapper=RootedNNISwap, verbosity=0)
```

### Implied weights analysis

The position of the root does not affect tree score, so we keep it fixed (using `RootedXXXSwap` functions) to avoid unnecessary swaps.

```{r treesearch-implied-weights-analysis, echo=TRUE, eval=FALSE}
for (k in kValues) {
  iw.tree <- IWRatchet(start.tree, iw_data, concavity=k,
                       ratchHits = 60, searchHits=55,
                       swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap),
                       verbosity=0L)
  score <- IWScore(iw.tree, iw_data, concavity=k)
  # Write a single best tree
  write.nexus(iw.tree,
              file=paste0("TreeSearch/hy_iw_k", k, "_", 
                          signif(score, 5), ".nex", collapse=''))

  iw.consensus <- IWRatchetConsensus(iw.tree, iw_data, concavity=k,
                  swappers=list(RootedTBRSwap, RootedNNISwap),
                  searchHits=55,
                  nSearch=150, verbosity=0L)
  write.nexus(iw.consensus, 
              file=paste0("TreeSearch/hy_iw_k", k, "_", 
                          signif(IWScore(iw.tree, iw_data, concavity=k), 5),
                          ".all.nex", collapse=''))
}
```

### Equal weights analysis

```{r treesearch-equal-weights-analysis, echo=TRUE, eval=FALSE}
ew.tree <- Ratchet(start.tree, my_data, verbosity=0L,
                   ratchHits = 25, searchHits=55, # ratchHits = 10 not enough
                   swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap))
ew.consensus <- RatchetConsensus(ew.tree, my_data, nSearch=250, searchHits = 55,
                                 swappers=list(RootedTBRSwap, RootedNNISwap),
                                 verbosity=0L)
write.nexus(ew.consensus, file=paste0(collapse='', "TreeSearch/hy_ew_",
                                      Fitch(ew.tree, my_data), ".nex"))
```

## Results

```{R treesearch-load-trees, echo=FALSE}
# Read results from files
source('treeFunctions.R')
ew.best <- list.files('TreeSearch', pattern='hy_ew_\\d*\\.nex', full.names=TRUE)
ew.trees <- read.nexus(file=ew.best[which.max(file.mtime(ew.best))])
ew.trees <- if (class(ew.trees) == 'multiPhylo') unique(ew.trees) else ew.trees
ew.trees <- as.multiPhylo(ew.trees)
iw.trees <- lapply(kValues, function (k) {
  iw.best <- list.files('TreeSearch', 
                      pattern=paste0('hy_iw_k',
                                     gsub('\\.', '\\\\.', k),
                                     '_\\d+\\.?\\d*\\.all\\.nex'),
                      full.names=TRUE)
  # Return:
  if (length(iw.best) == 0) {
    list()
  } else {
    loadedTrees <- read.nexus(iw.best[which.max(file.mtime(iw.best))])
    if (class(loadedTrees) == 'multiPhylo') unique(loadedTrees) else as.multiPhylo(loadedTrees)
  }
})
iw.exist <- iw.trees[vapply(iw.trees, length, 0) > 0]

allTrees <- ew.trees
for (i in seq_along(iw.exist)) {
  allTrees <- c(allTrees, iw.exist[[i]])
}

powersOf2 <- 2^(seq_along(allTrees[[1]]$tip.label)- 1) # Needed for GetSplits etc

tipIndex <- sort(allTrees[[1]]$tip.label)
allSplits <- GetSplits(allTrees, tipIndex)
```

(ref:ts-all-cons) Consensus of all parsimony results.  

(ref:node-support) Node labels denote the proportion of trees obtained under all analytical conditions that support the clade.  

```{r treesearch-maj-consensus, fig.cap="(ref:ts-all-cons) (ref:node-support)", fig.width=6, fig.height=5, echo=FALSE}
majCon <- RootTree(consensus(allTrees, p=0.5), rootingTips)
supporters <- SplitSupport(majCon, allSplits, tipIndex)

ColPlot(majCon)
nodelabels(paste0("\n\n", signif(supporters / length(allTrees), 3)),
           col=NodeColour(round(supporters / length(allTrees), 2)),
           adj=0, pos=2, frame='none', cex=0.75)

```

(ref:ts-trim-cons) Consensus of all parsimony results, with taxa omitted to show underlying clade support.  

```{r treesearch-maj-consensus-pruned, fig.cap="(ref:ts-trim-cons) (ref:node-support)", fig.width=6, fig.height=5, echo=FALSE}
#omit <- c("Micrina", 'Mickwitzia_muralensis', 'Heliomedusa_orienta')
omit <- c('Eccentrotheca')
allPruned <- lapply(allTrees, drop.tip, omit)
majCon <- RootTree(consensus(allPruned, p=0.5), rootingTips)
conTipIndex <- sort(majCon$tip.label)
conSplits <- GetSplits(allPruned, conTipIndex)

####
supporters <- SplitSupport(majCon, conSplits, conTipIndex)
####
ColPlot(majCon)
nodelabels(paste0("\n", signif(supporters / length(allTrees), 3)),
           col=NodeColour(round(supporters / length(allTrees), 2)),
           adj=0, pos=2, frame='none', cex=0.75)
ColMissing(omit)

```

(ref:ts-iw-cons) Strict consensus of implied weights analyses at all values of _k_. Wildcard taxa have been excluded from the consensus tree shown above to improve resolution.

```{r treesearch-iw-consensus, fig.cap="(ref:ts-iw-cons)", fig.width=6, fig.height=5, echo=FALSE}
ColPlot(ConsensusWithout(lapply(iw.exist, consensus), omit))
ColMissing(omit)
```

(ref:ts-iw-indiv) Consensus trees of implied weights analyses

(ref:first-panels) at all values of _k_, and at the individual values _k_ = `r kValues[1]`, `r kValues[2]` and `r kValues[3]`.

(ref:second-panels) at _k_ = `r paste(kValues[4:6], sep=', ')` and `r kValues[7]`.

\clearpage 

```{r treesearch-all-iw-results, fig.width=7.1, fig.height=8, fig.cap="(ref:ts-iw-indiv) (ref:first-panels)", echo=FALSE}
# Plot consensus results
par(mfrow=c(2, 2), mar=rep(0.2, 4))

ColPlot(RootTree(consensus(lapply(iw.exist, consensus)), rootingTips))
text(-0.5, 1, pos=4, "Strict consensus of all k values", cex=0.8)

PlotPanel(iw.trees, 1)
PlotPanel(iw.trees, 2)
PlotPanel(iw.trees, 3)
```

\clearpage 

```{R treesearch-iw-results-3, fig.width=7.1, fig.height=8, fig.cap="(ref:ts-iw-indiv) (ref:second-panels)", echo=FALSE}
par(mfrow=c(2, 2), mar=rep(0.2, 4))
PlotPanel(iw.trees, 4)
PlotPanel(iw.trees, 5)
PlotPanel(iw.trees, 6)
PlotPanel(iw.trees, 7)
```

\clearpage

```{r treesearch-equal-weights-results, fig.cap="Strict consensus of most parsimonious trees under equally weighted parsimony", echo=FALSE}
ColPlot(RootTree(consensus(ew.trees), rootingTips))
```


```{R treesearch-equal-weights-pruned-consensus, fig.cap="Strict consensus of equal weights results, taxa excluded", echo=FALSE}
omit <- c("Micrina", 'Mickwitzia_muralensis', 'Heliomedusa_orienta')
ColPlot(ConsensusWithout(ew.trees, omit))
ColMissing(omit)
```

\clearpage
