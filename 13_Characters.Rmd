---
title: "Visualizing characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Character reconstructions {#reconstructions}

This page provides definitions for each of the characters in our matrix, and justifies codings in particular taxa where relevant.  Further citations for codings that are not discussed in the text can be viewed by browsing the [morphological dataset](#dataset) on MorphoBank ([project 2800](https://morphobank.org/permalink/?P2800)). <mark>This link will become live on publication of the paper. Referees should follow the pre-publication link to the dataset that has been provided in the main manuscript.</mark>

Alongside each character's definition, we mapped each character onto a tree.
 `r if (knitr::is_html_output()) 'The tree used for reconstruction can be selected using the links below.' else 'Here, we have arbitrarily selected one most parsimonious tree obtained under implied weighting, $k = 4.5$. Other trees can be viewed in the HTML version of this file at \\href{https://ms609.github.io/hyoliths/reconstructions.html}{ms609.github.io/hyoliths}.'`
Each tip is labelled as it is coded in the matrix, and these states are used to reconstruct the condition of each internal node, using the parsimony method of @Brazeau2018 as implemented in the _Inapp_ _R_ package.

We emphasize that different trees will give different reconstructions.  The character mappings are not intended to definitively establish how each character evolved, but to help the reader quickly establish how each character has been coded, and to visualize at a glance how well the character fits onto the given tree.  We consider this more intuitive than the use of the flawed [@Archie1989] Consistency Index, but include this value because of its historic significance.

```{R char loading functions, echo=FALSE}
StrReplace <- stringi::stri_replace_all_fixed

LookUpReference <- function (keys, original, prefix='', suffix='') {
  keyParts <- "^~~~(.+?)(\\b.*)~~~$"
  keySuffixes <- gsub(keyParts, "\\2", keys, perl=TRUE)
  keys <- gsub(keyParts, "\\1", keys, perl=TRUE)
  if (length(keys) == 0) {
    return (character(0))
  } else if (length(keys) == 1) {
    matches <- grepl(keys, refKeys, fixed=TRUE)
    if (sum(matches) == 1) {
      paste0(prefix, refKeys[matches], keySuffixes, suffix)
    } else {
      paste0('<mark>', original, '</mark>')
    }
  } else { # length(keys) > 1
     # initialize
    ret <- paste0('<mark>', original, '</mark>')
    if (length(suffix) == 1) suffix <- rep(suffix, length(keys))
    if (length(prefix) == 1) prefix <- rep(prefix, length(keys))
    
    matches <- vapply(keys, FUN=grepl, FUN.VALUE=logical(length(refKeys)), refKeys, fixed=TRUE)
    uniques <- colSums(matches) == 1
    ret[uniques] <- vapply(which(uniques), function (i) 
      paste0(prefix[i], refKeys[matches[, i]], keySuffixes[i], suffix[i])
      , character(1))
    
    # Return:
    ret
  }
}

ConvertReferences <- function (string) {
  noParentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)?,? (\\d\\d\\d\\d\\w?)\\b"
  ReplNoPar <- function (keyedText, oldKey, original) {
    StrReplace(keyedText, oldKey,
                LookUpReference(oldKey, original, prefix='@'),
               vectorize_all=FALSE)
  }
  
  parentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)?,? \\((\\d\\d\\d\\d\\w?)\\b([^\\)]*)\\)"
  ReplPar <- function (keyedText, oldKey, original) {
    StrReplace(keyedText, oldKey,
                LookUpReference(oldKey, original, 
                  prefix=paste0(gsub(parentheses, "\\1\\2", original, perl=TRUE), ' [-@'),
                  suffix=']'
                ), vectorize_all=FALSE)
                
  }
  
  ReplaceRefs <- function (pattern, strings, Replace) {
    execResults <- gregexpr(pattern, strings, perl=TRUE)
    matchText <- lapply(regmatches(strings, execResults), unique)
    keyed <- gsub(pattern, "~~~\\1\\3\\4~~~", strings, perl=TRUE)
    keys <- lapply(matchText, function (citation) {
      ret <- gsub(pattern, "~~~\\1\\3\\4~~~", citation, perl=TRUE)
      duplicates <- ret[duplicated(ret)]
      substr(ret[duplicated(ret)], nchar(duplicates)-6, nchar(duplicates)-3) <- '!x2!'
      ret
    })
    toEdit <- which(vapply(keys, length, 0) > 0)
    strings[toEdit] <- vapply(toEdit, function (i) {
      Replace(keyed[i], keys[[i]], matchText[[i]])
    }, character(1))
    # Return:
    strings
  }
  
  matches <- grepl(noParentheses, string)
  string[matches] <- ReplaceRefs(noParentheses, string[matches], ReplNoPar)
  
  matches <- grepl(parentheses, string)
  string[matches] <- ReplaceRefs(parentheses, string[matches], ReplPar)
  
  string <- gsub("\\(([^\\)]*?@\\S+?[^\\)]*)\\)", "[\\1]", string, perl=TRUE)
  
  # Return:
  string
}

MorphoBankDecode <- function (string) {
  string <- gsub("^n", "  \n", string, fixed=TRUE)
  string <- gsub("''", "'", string, fixed=TRUE)
  string <- gsub(" - ", " -- ", string, fixed=TRUE)
  string <- gsub("(\\d)\\-(\\d)", "\\1--\\2", string, perl=TRUE)
  string <- gsub("(\\d) ?um\\b", "\\1 Âµm", string, perl=TRUE)
  string <- gsub(" et al ", " et al. ", string, fixed=TRUE)
  string <- gsub(" et alia", " et al.", string, fixed=TRUE)
  
  # Return:
  ConvertReferences(string)
}

EndSentence <- function (string) {
  ret <- gsub("\\s*\\.?\\s*\\.$", ".", paste0(string, '.'), perl=TRUE)
  ret <- gsub("(\\.[\"'])\\.$", "\\1", ret, perl=TRUE)
}

ReadNotes <- function (filepath) {
  lines <- enc2utf8(readLines(filepath))
  charNote.pattern <- "^\\s+TEXT\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  stateNote.pattern <- "^\\s+TEXT\\s+TAXON=(\\d+)\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  upperLines <- toupper(lines)
  notesStart <- which(upperLines == "BEGIN NOTES;")
  endBlocks <- which(upperLines == "ENDBLOCK;")
  if (length(notesStart) == 0) {
    return(list("NOTES block not found in Nexus file."))
  } else if (length(notesStart) > 1) {
    return(list("Multiple NOTES blocks found in Nexus file."))
  } else {
    notesEnd <- endBlocks[endBlocks > notesStart][1] - 1L
    notesLines <- lines[(notesStart + 1):notesEnd]
    charNote.matches <- grepl(charNote.pattern, notesLines, perl=TRUE)
    charNotes <- gsub(charNote.pattern, "\\2",
                       notesLines[charNote.matches], perl=TRUE)
    charNotes <- EndSentence(MorphoBankDecode(charNotes))
    charNumbers <- gsub(charNote.pattern, "\\1",
                              notesLines[charNote.matches], perl=TRUE)
    
    stateNote.matches <- grepl(stateNote.pattern, notesLines, perl=TRUE)
    stateNotes <- gsub(stateNote.pattern, "\\3",
                       notesLines[stateNote.matches], perl=TRUE)
    stateNotes <- EndSentence(MorphoBankDecode(stateNotes))
    stateTaxon <- gsub(stateNote.pattern, "\\1",
                              notesLines[stateNote.matches], perl=TRUE)
    stateChar  <- gsub(stateNote.pattern, "\\2",
                              notesLines[stateNote.matches], perl=TRUE)
    
    seqAlongNotes <- seq_len(max(as.integer(c(stateChar, charNumbers))))
    charNotes <- lapply(seqAlongNotes, function (i) {
      ret <- list(
        charNotes[charNumbers == i],
        stateNotes[stateChar == i])
      names(ret[[2]]) <- stateTaxon[stateChar == i]
      
      # Return:
      ret
    })
    names(charNotes) <- seqAlongNotes
    
    # Return:
    charNotes
  }
}

PrintStates <- function (states) {
  states <- gsub("^'(.*)'$", "\\1", states)
  tokens <- seq_along(states) - 1L
  if (states[1] == "") {
    states <- states[-1]
    tokens <- tokens[-1]
    transformational <- TRUE
  } else {
    transformational <- FALSE
  }
  cat(paste0(" > ", tokens, ": ", states, "  \n"))
  cat("> ", if (transformational) "Transformational" else "Neomorphic", "character.  \n>\n")
}


Italicize <- function (string) {
  string <- gsub(paste0("\\b(", 
                        paste0(gsub("_", "|", fixed = TRUE,
                                    c(taxa_names,
                                      'Bethia', 'Discinisca', 
                                      'Eichwaldia', 'Eoorthis',
                                      'Hadrotreta', 'Kraussina',
                                      'Lochkothele', 'Neocrania',
                                      'Paracraniops', 'Paramicrocornus',
                                      'Phoronopsis',
                                      'comleyensis', 'decaius',
                                      'schucherti', 'tenuis', 'worsleyi',
                                      'vascula', 'genitalia','lateralia',
                                      'media', 'myaria', 'terminalia',
                                      'levator ani',
                                      'et al\\.', 'et al', 'sensu')),
                               collapse='|'),
              ")\\b"), "_\\1_", string, perl=TRUE, ignore.case=FALSE)
  gsub("\\b([A-Z]\\.) _([a-z])", "_\\1 \\2", string, perl=TRUE)
}
```
```{R load-the-characters, echo=FALSE, message=FALSE}
if (!require('Inapp')) devtools::install_github('TGuillerme/Inapp')
library('Inapp')
if (knitr::is_html_output()) {
  trees <- unique(allTrees)
} else {
  trees <- iw.trees[[3]][2] # Single [] to keep as a list of 1 tree.
}
tree <- trees[[1]]
tree$edge.length <- rep(1, nrow(tree$edge))

char_names <- gsub("^'(.+)'$", "\\1", colnames(my_chars))
n_char <- ncol(my_chars)
char_parts <- strsplit(char_names, ": ")
char_nesting <- vapply(char_parts, length, 0L)
char_notes <- ReadNotes(filename)
taxa_names <- c("Namacalathus", rownames(my_chars))
taxa_sort <- taxa_names
taxa_plaintext <- gsub("_", " ", taxa_names, fixed=TRUE)
taxa_italic <- paste0("_", taxa_plaintext, "_")

index <- attr(my_data, 'index')
ci_text <- vapply(trees, function (tree) {
  fitch_consistency_index <- CI(tree, fitch_data, sitewise=TRUE)
  fitch_steps <- fitch(tree, fitch_data, site='site')[index]
  min_steps <- fitch_consistency_index * fitch_steps
  # Maximum steps is tricky to calculate, so we'll leave RI [= max-obs / max-min]
  # unless referees insist on it; neither it nor CI mean much in any case.
  fitch_retention_index <- RI(tree, fitch_data, sitewise=TRUE)
  fitch_retention_index <- ifelse(fitch_retention_index == 'NaN', 'n/a', signif(fitch_retention_index, 2))
  paste0('CI = ', signif(min_steps / FitchSteps(tree, my_data)[index], 2),
                  '; Fitch CI = ', signif(fitch_consistency_index, 2),
                  '; Fitch RI = ', fitch_retention_index)
}, character(n_char), USE.NAMES=FALSE)
```
```{R Javascript selection, echo=FALSE, asis=TRUE}
if (knitr::is_html_output()) {
  nTree <- c(length(ew.trees), vapply(iw.trees, length, 0))
  nTrees <- sum(nTree)
  treeIndex <- vapply(allTrees, 
                      function (tr1)
                        which(vapply(trees, all.equal, logical(1), tr1, 
                                     use.tip.label=TRUE, use.edge.length=FALSE)),
                      integer(1))
  TreeLink <- function (iNo, offset) {
    globalNo <- offset + iNo
    paste0('<span class="showTree uniqueTree', globalNo, '" onclick="showTree(', 
           globalNo, ', ', n_char, ');">[', iNo, ']</span>')
  }
  rows <- vapply(seq_along(nTree), function (i) {
    paste(TreeLink(1:nTree[i], treeIndex[i]), collapse=' ')
  }, '')
  names(rows) <- c('Equal weights', paste0('Implied weights, k = ', kValues))
  knitr::kable(rows, col.names='')
}
```
```{R character-mapping, echo=FALSE, fig.height=6.2, fig.width=7.1, results="asis"}
## These function definitions must be in the same block as when they are called.
Header <- function (level, content) paste0("  \n", paste0(rep('#', level), collapse=''), " ", content, "  \n")
PrintDivision <- function (parts) cat(Header(2L, paste(
  Italicize(this_char_parts[1:parts]), collapse=': ')))
PrintCharacter <- function () {
  cat(Header(3L, paste0("[", i, "] ", paste0(Italicize(
    this_char_parts[if(char_nesting[i] < 4) char_nesting[i] else 3:char_nesting[i]]),
    collapse=': '), " {-}")))
}
PrintSoloCharacter <- function () {
  cat(Header(2L, paste0(paste(
    Italicize(this_char_parts), collapse=': ')," [", i, "] ")))
}
DuplicateOf <- function (x) {
  duplicates <- duplicated(x)
  masters <- x[!duplicates]
  vapply(masters, function (d) x == d, logical(length(x)))
}
PrintStateNotes <- function (notes) {
  PrintThisNote <- function (note) {
    afflictedTaxa <- names(note)[note]
    master <- afflictedTaxa[1]
    cat("  \n",
        paste0("<div class='state-note' id='",
                     taxa_names[as.integer(master)], "-coding-", i,
                     "'>",
               paste(taxa_italic[as.integer(afflictedTaxa)], collapse=', '),
                      ": ", Italicize(notes[master]), "</div>  \n  \n"))
  }
  
  if (length(notes) == 1) {
    onlyOne <- TRUE
    names(onlyOne) <- names(notes)
    PrintThisNote(onlyOne)
  } else {
    notes <- notes[order(taxa_sort[as.integer(names(notes))])]
    duplicates <- DuplicateOf(toupper(notes))
    apply(duplicates, 2, PrintThisNote)
  }
}

taxa_not_to_print <- which(taxa_names %in% 'Namacalathus')
prev_char_parts = "NONE"
prev_nesting = 0
for (i in seq_len(n_char)) {
  
  this_char_parts <- char_parts[[i]]
  next_char_parts <- if (i == n_char) "LAST_CHARACTER" else char_parts[[i + 1L]]
  this_nesting <- char_nesting[i]
  next_nesting    <- if (i == n_char) 0 else char_nesting[i + 1L]
  
  if ( # Reasons to print a heading
    (this_char_parts[1] != prev_char_parts[1]) ||
    ( this_nesting > 1L && prev_nesting > 2L &&
      this_char_parts[2] != prev_char_parts[2]) ||
    ( this_nesting > 1L && prev_nesting > 1L && next_nesting > 2L &&
      this_char_parts[2] == next_char_parts[2] &&
      this_char_parts[2] != prev_char_parts[2])
  ) {
    if ( # Reasons to print a Solo character
      (this_char_parts[1] != next_char_parts[1] && 
       this_char_parts[1] != prev_char_parts[1]) ||
      (this_nesting == 2L && next_nesting > 1L &&
       prev_char_parts[1] == this_char_parts[1] &&
       next_char_parts[1] == this_char_parts[1]) ||
      (this_nesting == 1L && next_nesting > 1L &&
            next_char_parts[1] == this_char_parts[1]) ||
      prev_nesting > 2L && (
        next_nesting < 2L
        || (this_nesting > 1L && next_nesting > 2L && 
            (this_char_parts[2] != next_char_parts[2]))
      )
    ) {
      PrintSoloCharacter()
    }
    else if ( # Reasons to print a top-level heading
      this_nesting == 1 ||
      (next_nesting > 1 && (this_char_parts[2] != next_char_parts[2]))
    ) {
      PrintDivision(1)
      PrintCharacter()
    } else {
      PrintDivision(2)
      PrintCharacter()
    }
  } else { # Just print the character
    PrintCharacter()
  }
  prev_char_parts <- this_char_parts
  prev_nesting <- char_nesting[i]
  
  par(mar=rep(0.2, 4), cex=0.7)
  
  stateLabels <- my_states[[i]]
  my_chars_i <- my_chars[, i]
  null <- lapply(seq_along(trees), function (treeNo) {
    plot.states.matrix(apply.reconstruction(trees[[treeNo]], my_chars_i),
                       passes=0, counts=1:2, show.labels=1,
                       col.states=TRUE, state.labels=stateLabels,
                       use.edge.length=TRUE, legend.pos='topright')
    legend('bottomleft',  bty='n', ci_text[i, treeNo])
  })
  cat(paste0("  \n\n **Character ", i, ": ", Italicize(char_names[i]), "**  \n\n"))
  PrintStates(Italicize(my_states[[i]]))
  cat("  \n\n")
  char_notes_i <- char_notes[[i]]
  state_notes_i <- char_notes_i[[2]]
  state_notes_i <- state_notes_i[!names(state_notes_i) %in% taxa_not_to_print]
  if (length(char_notes_i[[1]]) > 0) cat(Italicize(char_notes_i[[1]]), "  \n")
  if (length(state_notes_i) > 0) PrintStateNotes(state_notes_i)
  cat("  \n") # Clear line, ready for next block
}
cat("<script>showTree(1, ", nChar, ");</script>")
```
