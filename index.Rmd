--- 
title: "Supplementary Information for: \\newline\\newline Hyoliths with pedicles constrain the origin of the brachiopod body plan"
author: "Haijing Sun, Martin R. Smith, Han Zeng, Fangchen Zhao, Guoxiang Li and Maoyan Zhu"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: 
  bookdown::pdf_book:
    includes:
      in_header: preamble.tex
    keep_tex: true
documentclass: book
classoption: openany
bibliography: [References.bib]
csl: http://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
biblio-style: apalike-doi
link-citations: yes
github-repo: ms609/hyoliths
description: "Results of phylogenetic analysis"
---

# Supplementary Text {-}

This document comtains supplementary material to @Sun2018Hyolithswith.  `r if (knitr::is_latex_output()) 'It is best viewed in HTML format at \\href{https://ms609.github.io/hyoliths/}{ms609.github.io/hyoliths}.'`

It opens with a detailed discussion of [analyses](#treesearch) of the [morphological dataset](#dataset) constructed to accompany @Sun2018Hyolithswith, and their results.

We document the results of tree searches using [Fitch parsimony](#fitch) and a [Bayesian method](#bayesian), with the caveat that both approaches are subject to errors resulting from logically incoherent treatment of inapplicable data [@Maddison1993].

To meet this criticism, we also present the results of tree searches with the algorithm described by @Brazeau2018, which correctly handles inapplicable data in a parsimony setting. Finally, we document how each character is most parsimoniously [reconstructed](#reconstructions) on `r if(knitr::is_html_output()) "optimal trees" else "an optimal tree"`.

Supplementary [figures](#figures) and [tables](#table) appear after the text.

```{r setup-index, include=FALSE, message=FALSE}
Sys.setlocale('LC_ALL','English_United Kingdom.1252');
set.seed(0)
knitr::opts_chunk$set(echo = TRUE)
library('ape'); library('phangorn'); library('TreeSearch');
if (!require('Inapp')) devtools::install_github('TGuillerme/Inapp')
library('Inapp')
source('bibFunctions.R')
source('helperFunctions.R')
source('plotFunctions.R')
source('printFunctions.R')
source('treeFunctions.R')
```
```{R Morphobank bibliography, echo=FALSE, message=FALSE}
mbBib <- list.files(pattern='morphobank_bibliography.*\\.txt', full.names=TRUE)
mbRecent <- mbBib[which.max(file.mtime(mbBib))]
refs <- trimws(enc2utf8(as.matrix(read.delim(mbRecent, sep="\t", header=TRUE, skip=1, row.names=NULL))))

#bibFile <- file("MorphoBank.bib", encoding='UTF-8')
#writeLines(apply(refs, 1, BibEntry), bibFile)
#close(bibFile)
refKeys <- apply(refs, 1, RefKey) # Needed before ReadNotes
```
```{R setup-more, include=FALSE, message=FALSE}
tntFiles <- list.files('TNT/', pattern='xpiwe.*\\.tre', full=TRUE)
tntDataFile <- gsub(".*(mbank_.*\\.tnt).*", "\\1", readLines(tntFiles[1], n=1))
nexusFiles <- list.files(pattern='mbank_.*\\.nex', full.names=TRUE)
nexusFile <- nexusFiles[which.max(vapply(nexusFiles, NexusTime, double(1)))]
my_data <- ReadAsPhyDat(nexusFile)
#ignored_taxa <- c('Conotheca', 'Decoritheca', 'Maxilites', 'Pauxillites',
#                  'Probactrotheca') # Also manually update tnt.run with with taxcode-
ignored_taxa <- c('Decoritheca')
#ignored_taxa <- character(0)
my_data[ignored_taxa] <- NULL

# my_data contains an inapplicable state that we should convert to ambiguous for 
# standard fitch, for CI etc.
iw_data <- PrepareDataIW(my_data)
fitch_data <- my_data
cont <- attr(fitch_data, 'contrast')
cont[cont[, '-'] == 1, ] <- 1
attr(fitch_data, 'contrast') <- cont

my_chars <- ReadCharacters(nexusFile)
char_notes <- ReadNotes(nexusFile)
my_states <- attr(my_chars, 'state.labels')
my_chars <- my_chars[!(rownames(my_chars) %in% ignored_taxa), ]

neomorphic <- vapply(my_states, function(x) !x[[1]] %in% c("", "''"), logical(1))

kValues <- c(2, 3, 4.5, 7, 10.5, 16, 24)

powersOf2 <- 2^(seq_along(my_data) - 1) # Needed for GetSplits etc

outgroup <- 'Namacalathus'
outgroup <- 'Loxosomella'
rootingTips <- c('Tonicella', 'Serpula', 'Loxosomella')

# Copied from latest GitHub version of TreeSearch
RootTree <- function (tree, outgroupTips) {
  tipLabel <- tree$tip.label
  tipNos <- which(tipLabel %in% outgroupTips)
  ancestry <- unlist(Ancestors(tree, tipNos))
  ancestryTable <- table(ancestry)
  lineage <- as.integer(names(ancestryTable))
  lca <- max(lineage[ancestryTable == length(outgroupTips)])
  rootNode <- length(tipLabel) + 1L
  if (lca == rootNode) {
    lca <- lineage[lineage - c(lineage[-1], 0) != -1][1] + 1L
  }
  Renumber(root(tree, Descendants(tree, lca)[[1]], resolve.root = TRUE))
}

```



