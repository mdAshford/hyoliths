--- 
title: "Brachiopod origins - Supplementary material - Phylogenetic analysis"
author: "Sun, Hai-Jing; Smith, Martin Ross; Zhu, Mao-Yan; Zeng, Han; Zhao, Fang-Chen"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [References.bib, MorphoBank.bib]
link-citations: yes
github-repo: ms609/hy
description: "Results of phylogenetic analysis"
---

```{r setup, include=FALSE}
set.seed(0)
knitr::opts_chunk$set(echo = TRUE)
library('TreeSearch'); library('ape'); library('phangorn')
files <- list.files(pattern='mbank_.*\\.nex', full.names=TRUE)
filename <- files[which.max(file.mtime(files))]
my_data <- ReadAsPhyDat(filename)
my_chars <- ReadCharacters(filename)
my_states <- attr(my_chars, 'state.labels')
my_chars <- my_chars[-1, ]
neomorphic <- vapply(my_states, function(x) x[[1]] %in% c("", "''"), logical(1))
setPar <- function() par(mar=rep(0.2, 4), cex=0.8)

lon <- 'Longtancunella_chengjiangensis'

pal <- TreeSearch::brewer[[11]]

tipCol <- c(
  Namacalathus                    = pal[1],
  Novocrania                      = pal[4],
  Craniops                        = pal[4],
  Ussunia                         = pal[4],
  Gasconsia                       = pal[4],
  Heliomedusa_orienta             = pal[3],
  Heliomedusa                     = pal[3],
  Micrina                         = pal[3],
  Mickwitzia_muralensis           = pal[3],
  Mickwitzia                      = pal[3],
  Micromitra                      = pal[8],
  Askepasma_toddense              = pal[8],
  Askepasma              = pal[8],
  Pelagodiscus_atlanticus         = pal[6],
  Pelagodiscus         = pal[6],
  Mummpikia_nuda                  = pal[5],
  Mummpikia                  = pal[5],
  Lingula                         = pal[5],
  Eoobolus                        = pal[5],
  Clupeafumosus_socialis          = 'grey',
  Clupeafumosus          = 'grey',
  Phoronis                        = pal[1],
  Dailyatia                       = pal[1],
  Eccentrotheca                   = pal[1],
  Yuganotheca_elegans             = 'grey',
  Yuganotheca             = 'grey',
  Longtancunella_chengjiangensis  = 'grey',
  Longtancunella  = 'grey',
  Paterimitra                     = pal[1],
  Lingulellotreta_malongensis     = pal[2],
  Lingulellotreta     = pal[2],
  Acanthotretella                 = pal[2],
  Lingulosacculus                 = pal[2],
  Pedunculotheca_diania           = pal[2],
  Pedunculotheca           = pal[2],
  Haplophrentis_carinatus         = pal[2],
  Haplophrentis         = pal[2],
  Tomteluva_perturbata            = 'grey',
  Tomteluva            = 'grey',
  Salanygolina                    = pal[9],
  Coolinia_pecten                 = pal[9],
  Coolinia                 = pal[9],
  Antigonambonites_planus         = pal[9],
  Antigonambonites         = pal[9],
  Kutorgina_chengjiangensis       = pal[10],
  Kutorgina       = pal[10],
  Nisusia_sulcata                 = pal[10],
  Nisusia                 = pal[10],
  Alisina                         = pal[11],
  Glyptoria                       = pal[11],
  Orthis                          = pal[11],
  Terebratulina                   = pal[11])


ColPlot <- function (tree) {
  setPar()
  plot(tree, tip.color = tipCol[tree$tip.label], lwd=2)
}
ColMissing <- function (omit) MarkMissing(omit, text.font=3, cex=0.8,
                                          text.col=tipCol[omit])
```

# Brachiopod origins {-}

This document provides a detailed discussion of analyses of the [morphological dataset](#dataset) constructed to accompany Sun _et al._ [-@Sun2018], and their results.

We first discuss the results presented in the main paper, which employ the algorithm described by Brazeau, Guillerme and Smith [-@Brazeau2018] for correct handling of inapplicable data in a parsimony setting, and explore how each
character is [reconstructed](#reconstructions) on an optimal tree.

For completeness, we also document the results of [standard Fitch parsimony](#tnt) analysis, and the results of [Bayesian analysis](#MrBayes), neither of which treat inapplicable data in a logically consistent fashion.

<!--chapter:end:index.Rmd-->

---
title: "Phylogenetic dataset"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# The dataset

Analysis was performed on a new matrix of `r length(names(my_data)) - 1L` early brachiozoan taxa, including hyoliths, tommotiids and mickwitziids, which were coded for `r sum(attr(my_data, 'weight'))` morphological characters (`r sum(neomorphic)` neomorphic, `r sum(!neomorphic)` transformational).

The dataset can be viewed and downloaded at Morphobank ([project 2800](https://morphobank.org/permalink/?P2800)), where each character is defined
and its coding for each taxon discussed.

Characters are coded following the recommendations of Brazeau, Guillerme and
Smith [@Brazeau2018].  In brief, we have employed reductive coding, using a distinct state to mark character inapplicability. Character specifications follow the model of Sereno [-@Sereno2007].

We have distinguished between neomorphic and transformational characters [sensu @Sereno2007] by reserving the token `0` to refer to the absence of a neomorphic character.  The states of transformational characters are represented by the tokens `1`, `2`, `3`, ...

Following the recommendations of Brazeau, Guillerme and
Smith [@Brazeau2018, supplementary discussion], we code the absence of neomorphic ontologically dependent characters [sensu @Vogt2017] as absence, rather than inapplicability.


<!--chapter:end:01_Dataset.Rmd-->

---
title: "TreeSearch results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# Parsimony analysis {#treesearch}

The phylogenetic dataset contains a high proportion of inapplicable codings (`r sum(my_chars == '-')`/ `r length(my_chars)` = `r round(sum(my_chars == '-') / length(my_chars), 2) * 100`% of tokens), which are known to introduce error and bias to phylogenetic reconstruction ([@Maddison1993;@Brazeau2018]).  As such, phylogenetic search employed a new algorithm that correctly handles inapplicable data [@Brazeau2018].  This algorithm is implemented in the _MorphyLib_ C library [@Brazeau2017Morphylib], and phylogenetic search was conducted using the _R_ package _TreeSearch_ v0.0.8 [@Smith2018TreeSearch].

_Namacalathus_ is included in the matrix but has been excluded from analysis due to its potentially long branch, which is likely to mislead analysis.

## Search parameters

Heuristic searches were conducted using the parsimony ratchet [@Nixon1999] under equal and implied weights [@Goloboff1997] with a variety of concavity constants.  The consensus tree presented in the main manuscript represents a strict consensus of all trees that are most parsimonious under one or more of the concavity constants (_k_) 2, 3, 4.5, 7, 10.5, 16 and 24, an approach that is known to produce higher accuracy than equal weights at any fixed level of precision [@Smith2017].

## Analysis 

### Load data

```{r TS Load morphoBank, echo=FALSE}
# Load file from MorphoBank
my_data <- ReadAsPhyDat(filename)
my_data$Namacalathus <- NULL # Exclude Namacalathus

iw_data <- PrepareDataIW(my_data)
kValues <- c(2, 3, 4.5, 7, 10.5, 16, 24)
```

### Generate starting tree

_Dailyatia_ has been selected as an outgroup as camenellans have been interpreted as the earliest diverging members of the Brachiozoa [@Skovsted2015;@Zhao2017].

```{R Starting tree, cache=TRUE}
nj.tree <- NJTree(my_data)
rooted.tree <- EnforceOutgroup(nj.tree, 'Dailyatia')
start.tree <- TreeSearch(tree=rooted.tree, dataset=my_data, maxIter=3000,
                         EdgeSwapper=RootedNNISwap, verbosity=0)
```

### Implied weights analysis

```{r Implied weights analysis in TreeSearch, cache=TRUE, eval=FALSE}
for (k in kValues) {
  iw.tree <- IWRatchet(start.tree, iw_data, concavity=k,
                       ratchHits = 60, searchHits=55,
                       swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap),
                       verbosity=0)
  score <- IWScore(iw.tree, iw_data, concavity=k)
  # Write single best tree
  write.nexus(iw.tree, file=paste0("TreeSearch/hy_iw_k", k, "_", signif(score, 5), ".nex", collapse=''))

  suboptFraction = 0.02
  iw.consensus <- IWRatchetConsensus(iw.tree, iw_data, concavity=k,
                  swappers=list(RootedTBRSwap, RootedNNISwap),
                  searchHits=4,
                  suboptimal=score * suboptFraction,
                  nSearch=150, verbosity=0L)
  write.nexus(iw.consensus, file=paste0("TreeSearch/hy_iw_k", k, "_", signif(IWScore(iw.tree, iw_data, concavity=k), 5), ".all.nex", collapse=''))
}
```

### Equal weights analysis

```{r Equal weights analysis in TreeSearch, cache=TRUE, eval=FALSE}
ew.tree <- Ratchet(start.tree, my_data, verbosity=0L,
                   ratchHits = 10, searchHits=55,
                   swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap))
write.nexus(best.tree, file=paste0("TreeSearch/hy_ew_", Fitch(ew.tree, my_data), ".nex", collapse=''))

ew.consensus <- RatchetConsensus(ew.tree, my_data, nSearch=150,
                                 swappers=list(RootedTBRSwap, RootedNNISwap),
                                 verbosity=0L)
write.nexus(ew.consensus, file=paste0("TreeSearch/hy_ew_", Fitch(ew.tree, my_data), ".nex", collapse=''))
```

## Results

### Implied weights results

```{R "Load IW trees TreeSearch"}
# Read results from files
iw.trees <- lapply(kValues, function (k) {
  iw.best <- list.files('TreeSearch', 
                      pattern=paste0('hy_iw_k',
                                     gsub('\\.', '\\\\.', k),
                                     '_\\d+\\.?\\d*\\.all\\.nex'),
                      full.names=TRUE)
  # Return:
  if (length(iw.best) == 0) {
    list()
  } else {
    read.nexus(iw.best[which.max(file.mtime(iw.best))])
  }
})
```



```{r, fig.cap="Consensus of implied weights analyses at all values of k", fig.width=6, fig.height=5}
omit=c(lon, 'Clupeafumosus_socialis',
       'Heliomedusa_orienta', 'Haplophrentis_carinatus')
ColPlot(ConsensusWithout(lapply(iw.trees, consensus), omit))
ColMissing(omit)
```



```{r, fig.cap="Implied weights results", fig.width=7.1, fig.height=10.5}
# Plot consensus results
par(mfrow=c(4, 2), mar=rep(0.2, 4))

ColPlot(consensus(lapply(iw.trees, consensus)))
text(-0.5, 1, pos=4, "Consensus of all k values", cex=0.8)

# Plot results for each value of k
for (i in seq_along(iw.trees)) {
  ColPlot(consensus(iw.trees[[i]]))
  text(1, 1, paste0('k = ', kValues[i]), pos=4)
}

```

### Equal weights results

```{r "equal weights results in TreeSearch", fig.cap="Strict consensus of equal weights results"}
ew.best <- list.files('TreeSearch', pattern='hy_ew_\\d*\\.nex', full.names=TRUE)
ew.tree <- read.nexus(file=ew.best[which.max(file.mtime(ew.best))])
ColPlot(consensus(ew.tree))
```

```{R, fig.cap="Strict consensus of equal weights results, taxa excluded"}
omit <- c(lon)
ColPlot(ConsensusWithout(ew.tree, omit))
ColMissing(omit)
```

<!--chapter:end:02_TreeSearch.Rmd-->

---
title: "Visualizing characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib, MorphoBank.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# Character reconstructions {#reconstructions}

```{R, echo=FALSE}
library('Inapp')
tree <- iw.trees[[3]][[1]]
tree$edge.length <- rep(1, nrow(tree$edge))

ReadNotes <- function (filepath) {
  lines <- readLines(filepath)
  charNote.pattern <- "^\\s+TEXT\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  stateNote.pattern <- "^\\s+TEXT\\s+TAXON=(\\d+)\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  upperLines <- toupper(lines)
  notesStart <- which(upperLines == "BEGIN NOTES;")
  endBlocks <- which(upperLines == "ENDBLOCK;")
  if (length(notesStart) == 0) {
    return(list("NOTES block not found in Nexus file."))
  } else if (length(notesStart) > 1) {
    return(list("Multiple NOTES blocks found in Nexus file."))
  } else {
    notesEnd <- endBlocks[endBlocks > notesStart][1] - 1L
    notesLines <- lines[(notesStart + 1):notesEnd]
    charNote.matches <- grepl(charNote.pattern, notesLines, perl=TRUE)
    charNotes <- gsub(charNote.pattern, "\\2",
                       notesLines[charNote.matches], perl=TRUE)
    charNotes <- gsub("^n", "  \n", charNotes, fixed=TRUE)
    charNotes <- gsub("''", "'", charNotes, fixed=TRUE)
    charNumbers <- gsub(charNote.pattern, "\\1",
                              notesLines[charNote.matches], perl=TRUE)
    
    stateNote.matches <- grepl(stateNote.pattern, notesLines, perl=TRUE)
    stateNotes <- gsub(stateNote.pattern, "\\3",
                       notesLines[stateNote.matches], perl=TRUE)
    stateNotes <- gsub("^n", "  \n", stateNotes, fixed=TRUE)
    stateTaxon <- gsub(stateNote.pattern, "\\1",
                              notesLines[stateNote.matches], perl=TRUE)
    stateChar  <- gsub(stateNote.pattern, "\\2",
                              notesLines[stateNote.matches], perl=TRUE)
    
    charNotes <- lapply(seq_len(max(c(stateChar, charNumbers))), function (i) {
      ret <- list(
        charNotes[charNumbers == i],
        stateNotes[stateChar == i])
      names(ret[[2]]) <- stateTaxon[stateChar == i]
      
      # Return:
      ret
    })
    names(charNotes) <- charNumbers
    
    # Return:
    charNotes
  }
}

PrintStates <- function (states) {
  tokens <- seq_along(states) - 1L
  if (states[1] == "''") {
    states <- states[-1]
    tokens <- tokens[-1]
    transformational <- TRUE
  } else {
    transformational <- FALSE
  }
  cat(paste0(" > ", tokens, ": ", states, "  \n"))
  cat("> ", if (transformational) "Transformational" else "Neomorphic", " character.  \n>\n")
}

char_names <- gsub("^'(.+)'$", "\\1", colnames(my_chars))
char_notes <- ReadNotes(filename)
taxa_names <- c("Namacalathus", rownames(my_chars))
taxa_plaintext <- gsub("_", " ", taxa_names, fixed=TRUE)
taxa_italic <- paste0("_", taxa_plaintext, "_")
Italicize <- function (text) {
  gsub(paste0("\\b(", paste0(gsub("_", "|", taxa_names, fixed = TRUE), collapse='|'),
              ")\\b"), "_\\1_", text, perl=TRUE, ignore.case=TRUE)
}
#treeCol <- tipCol[tree$tip.label]
```

This page defines each characer and accounts for its coding in particular taxa.  Citations for all codings can be found by browsing the [morphological dataset](#dataset) on MorphoBank ([project 2800](https://morphobank.org/permalink/?P2800)).

The _Inapp_ _R_ package [@Brazeau2018] was used to map each character onto one of the most parsimonious trees (obtained under implied weighting, $k = 4.5$):


```{R, echo=FALSE, fig.height=6.6, fig.width=7.1, results="asis"}
for (i in seq_len(ncol(my_chars))) {
  cat("\n## ", char_names[i], " {-}  \n")
  
  par(mar=rep(0.2, 4), cex=0.7)
  
  plot.states.matrix(apply.reconstruction(tree, my_chars[, i]),
                     passes=0, counts=1:2, show.labels=1,
                     col.states=TRUE, state.labels=my_states[[i]],
                     #tip.col=treeCol, 
                     use.edge.length=TRUE, legend.pos='topright')
  
  cat("  \n\n **Character ", i, ": ", char_names[i], "**  \n\n")
  PrintStates(my_states[[i]])
  cat("  \n\n")
  char_notes_i <- char_notes[[i]]
  state_notes_i <- char_notes_i[[2]]
  if (length(char_notes_i[[1]]) > 0) cat(Italicize(char_notes_i[[1]]), "  \n")
  if (length(state_notes_i) > 0) {
    cat("  \n ", paste0(taxa_italic[as.integer(names(state_notes_i))],
                      ": ", Italicize(state_notes_i), "  \n  \n "))
  }
  cat("  \n") # Clear line, ready for next block
}
```


```{R Morphobank bibliography, echo=FALSE}
mbBib <- list.files(pattern='morphobank_bibliography.*\\.txt', full.names=TRUE)
mbRecent <- mbBib[which.max(file.mtime(mbBib))]
refs <- as.matrix(read.delim(mbRecent, sep="\t", header=TRUE, skip=1, row.names=NULL))
FirstWord <- function (text) gsub("^(\\w+).*$", "\\1", trimws(text), perl=TRUE)
FirstWords <- function (text) gsub("^\\W*(\\w+)\\W*(\\w+)?.*", "\\1\\2", trimws(text), perl=TRUE)
FormatAuthors <- function (text) {
  authors <- trimws(strsplit(text, ';')[[1]])
  names.pattern <- "(\\w+,)\\s(.*)"
  surnames <-  gsub(names.pattern, "\\1 ", authors)
  forenames <- gsub(names.pattern, "\\2", authors)
  forenames <- gsub("(\\w)\\w+\\.?", "\\1.", forenames)
  forenames <- gsub("\\.(\\w)", ". \\1", forenames)
  
  # Return:
  paste0(surnames, forenames, collapse=' and ')
}
RefKey <- function (ref) paste0(FirstWord(ref['Author']),
                                trimws(ref['Year']),
                                FirstWords(ref['Title']))
BibEntry <- function (ref) {
  BibLine <- function (bibKey, key, text=ref[key]) {
    if (is.na(ref[key]) || ref[key] == "") "" else  paste0("  ", bibKey, " = {", trimws(text), "},\n")
  }
  refType <- tolower(FirstWord(ref['Reference.Type']))
  if (refType %in% c('generic', 'journal')) refType <- 'article'
  paste0("@", refType, '{', 
         RefKey(ref), ",\n",
         BibLine('author', 'Author', FormatAuthors(ref['Author'])),
         BibLine('doi', 'DOI'),
         BibLine('journal', 'Secondary.Title'),
         BibLine('title', 'Title', paste0('{', gsub("</?i>", "_", ref["Title"], perl=TRUE), '}')),
         BibLine('number', 'Number'),
         BibLine('pages', 'Pages', gsub("\\-+", "--", ref["Pages"], perl=TRUE)),
         BibLine('volume', "Volume"),
         BibLine('year', 'Year'),
         "}\n"
         )
}

bibFile <- file("MorphoBank.bib", encoding='UTF-8')
writeLines(apply(refs, 1, BibEntry), bibFile)
close(bibFile)
```

```{R Character references from MorphoBank, echo=FALSE, results='asis'}
cat(paste0('[@', paste0(apply(refs, 1, RefKey), collapse=';@'), ']'))
```

<!--chapter:end:03_Characters.Rmd-->

---
title: "Standard (Fitch) parsimony results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---


# Fitch parsimony {#tnt}

Parsimony search was conducted in TNT v1.5 [@Goloboff2016] using sectorial and ratchet heuristics [@Goloboff1999;@Nixon1999] under equal and implied weights [@Goloboff1997].  We acknowledge the Willi Hennig Society for their sponsorship of the TNT software.

```{R, echo=FALSE}
tntFiles <- list.files('TNT/', pattern='xpiwe.*\\.tre', full=TRUE)
filename <- tntFiles[1]
tnTrees <- lapply(tntFiles, ReadTntTree)
```

## Implied weights

The consensus of all implied weights runs is not very well resolved:

```{R, echo=FALSE, fig.wid=7.1, fig.height=4}
par(mfrow=c(1, 2))
ColPlot(consensus(tnTrees)) 
text(1, 0.5, 'Consensus of all k values', pos=4, cex=0.6)

plotPanel <- function (i) {
  ColPlot(tnTrees[[i]])
  text(1, 0.5, paste('k =', kValues[i]), pos=4, cex=0.6)
}

plotPanel(1)
```
```{R, echo=FALSE}
par(mfrow=c(1, 2))
plotPanel(2)
plotPanel(3)
```

```{R, echo=FALSE}
par(mfrow=c(1, 2))
plotPanel(4)
plotPanel(5)
```

```{R, echo=FALSE}
par(mfrow=c(1, 2))
plotPanel(6)
plotPanel(7)
```

This lack of resolution is largely a product of a few wildcard taxa, which obscure relationships that are nevertheless present in all most parsimonious trees:

### Paterinids included

```{R, echo=FALSE, fig.cap="TNT implied weights consensus"}
omit <- c('Clupeafumosus_socialis', 'Micrina', 'Mickwitzia_muralensis', 'Paterimitra', 'Heliomedusa_orienta', 'Tomteluva_perturbata', 'Yuganotheca_elegans', 'Salanygolina', 'Gasconsia', 'Mummpikia_nuda')
ColPlot(ConsensusWithout(tnTrees, omit))
ColMissing(omit)
```

### Paterinids excluded

```{R, echo=FALSE, fig.cap="TNT implied weights consensus"}
omit <- c('Clupeafumosus_socialis', 'Micrina', 'Mickwitzia_muralensis', 'Paterimitra', 'Heliomedusa_orienta', 'Tomteluva_perturbata', 'Yuganotheca_elegans', 'Salanygolina', 'Gasconsia', 'Mummpikia_nuda', 'Kutorgina_chengjiangensis', 'Nisusia_sulcata')
ColPlot(ConsensusWithout(tnTrees, omit))
ColMissing(omit)
```


## Equal weights

```{R, echo=FALSE, fig.cap="TNT Equal weights consensus"}
tntEw <- list.files('TNT/', pattern='ew\\.tre', full=TRUE)
ColPlot(ConsensusWithout(ReadTntTree(tntEw), lon))
ColMissing(lon)
```

<!--chapter:end:04_TNT.Rmd-->

---
title: "Bayesian Analysis results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---


# Bayesian analysis

```{R, echo=FALSE}
files <- list.files('MrBayes', pattern='^hyo\\..*\\.t$', full.names=TRUE)

allTrees <- lapply(files, read.nexus)
nTrees <- length(allTrees[[1]])

postBurnin <- lapply(allTrees, function (x) x[ceiling(nTrees * 0.1):nTrees])
```

Bayesian search was conducted in MrBayes v3.2.6 [@Ronquist2012] using the Mk model [@Lewis2001] with a gamma parameter:

> lset coding=variable rates=gamma;

Branch length was drawn from a dirichlet prior distribution, which is less informative than an exponential model [@Rannala2012], but requires a prior mean tree length within about two orders of magnitude of the true value [@Zhang2012]. To satisfy this latter criterion, we specified the prior mean tree length to be equal to the length of the most parsimonious tree under equal weights, usinga Dirichlet prior with $α_T = 1$, $β_T = 1/$(_equal weights tree length_ / _number of characters_), $α = c = 1$:

> prset brlenspr = unconstrained: gammadir(1, 0.33, 1, 1);

Neomorphic and transformational characters [sensu @Sereno2007] were allocated to two separate partitions whose proportion of invariant characters and gamma shape parameters were allowed to vary independently:

> charset Neomorphic = `r paste(which(neomorphic), collapse=' ')`;
>
> charset Transformational = `r paste(which(!neomorphic), collapse=' ')`;
>
>
> partition chartype = 2: Neomorphic, Transformational;
>
> set partition = chartype;
>
>
> unlink shape=(all) pinvar=(all);


Neomorphic characters were not assumed to have a symmetrical transition rate – that is, the probability of the absent → present transition was allowed to differ from that of the present → absent transition, being drawn from a uniform prior:

> prset applyto=(1) symdirihyperpr=fixed(1.0);

Four MrBayes runs were executed, each sampling eight chains for 1 000 000 generations, with samples taken every 500 generations:

> mcmcp ngen=1000000 samplefreq=500 nruns=2 nchains=8;

The first 10% of samples were discarded as burn-in (`burninfrac=0.1`), and a posterior tree topology was derived from the combined posterior sample of both runs.

```{R, echo=FALSE, fig.cap="Bayesian analysis, posterior probability > 50%"}
omit <- c("none")
 # 'Novocrania', 'Craniops', 'Ussunia', 'Gasconsia',
thinned <- c(lapply(postBurnin[[1]], drop.tip, omit),
             lapply(postBurnin[[2]], drop.tip, omit),
             lapply(postBurnin[[3]], drop.tip, omit),
             lapply(postBurnin[[4]], drop.tip, omit))
class(thinned) <- 'multiPhylo'
ColPlot(consensus(thinned, p=0.5))
ColMissing(omit)
```

```{R, echo=FALSE, fig.cap="Bayesian analysis, posterior probability > 50%"}
omit <- c('Heliomedusa', 'Micrina', 'Mickwitzia',
          'Eoobolus', 'Clupeafumosus', 
          'Yuganotheca', 'Longtancunella', 'Tomteluva', 'Nisusia', 'Kutorgina')
thinned <- c(lapply(postBurnin[[1]], drop.tip, omit),
             lapply(postBurnin[[2]], drop.tip, omit),
             lapply(postBurnin[[3]], drop.tip, omit),
             lapply(postBurnin[[4]], drop.tip, omit))
class(thinned) <- 'multiPhylo'
ColPlot(consensus(thinned, p=0.5))
ColMissing(omit)
```

Convergence was indicated by PSRF = 1.00 and an average estimated sample size of > 500 for each parameter:

```{R, MrBayes parameter summary, echo=FALSE, asis=TRUE}
knitr::kable(read.table ('MrBayes/hyo.nex.pstat', skip=1, header=TRUE),
             caption="MrBayes parameter estimates (.pstat file)")
```

It's interesting to note that the clade of hyoliths + lingulellotretids (+ relatives) is resolved as a grade under Bayesian analysis.  

In parsimony analysis, these taxa are always resolved as a clade when inapplicable data is correctly handled; they instead resolve as a grade under certain conditions under the [standard Fitch](#TNT) algorithm (which mishandles inapplicable data).

We suggest that the failure of Bayesian analysis to recover this group as a clade may reflect inappropriate handling of inapplicable data in MrBayes, though at present (and until the algorithms used in a likelihood context are improved) it is difficult to test this hypothesis.

The same goes for the position of _Gasconsia_, which is widely held to have an affinity with the craniid brachiopods, and is recovered in such a position using the inapplicable-safe parsimony algorithm (but not always when the standard Fitch parsimony algorithm is used).

<!--chapter:end:05_MrBayes.Rmd-->

