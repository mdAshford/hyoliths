--- 
title: "Brachiopod origins - Supplementary material - Phylogenetic analysis"
author: "Sun, Hai-Jing; Smith, Martin Ross; Zhu, Mao-Yan; Zeng, Han; Zhao, Fang-Chen"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [References.bib]
link-citations: yes
github-repo: ms609/hy
description: "Results of phylogenetic analysis"
---

```{r setup, include=FALSE}
set.seed(0)
knitr::opts_chunk$set(echo = TRUE)
library('TreeSearch'); library('ape'); library('phangorn')
files <- list.files(pattern='mbank_.*\\.nex', full.names=TRUE)
filename <- files[which.max(file.mtime(files))]
my_data <- ReadAsPhyDat(filename)
my_chars <- ReadCharacters(filename)
my_states <- attr(my_chars, 'state.labels')
my_chars <- my_chars[-1, ]
neomorphic <- vapply(my_states, function(x) x[[1]] %in% c("", "''"), logical(1))
setPar <- function() par(mar=rep(0.2, 4), cex=0.8)


lon <- 'Longtancunella_chengjiangensis'

pal <- TreeSearch::brewer[[11]]

tipCol <- c(
  Namacalathus                    = pal[1],
  Novocrania                      = pal[4],
  Craniops                        = pal[4],
  Ussunia                         = pal[4],
  Gasconsia                       = pal[4],
  Heliomedusa_orienta             = pal[3],
  Heliomedusa                     = pal[3],
  Micrina                         = pal[3],
  Mickwitzia_muralensis           = pal[3],
  Mickwitzia                      = pal[3],
  Micromitra                      = pal[8],
  Askepasma_toddense              = pal[8],
  Askepasma              = pal[8],
  Pelagodiscus_atlanticus         = pal[6],
  Pelagodiscus         = pal[6],
  Mummpikia_nuda                  = pal[5],
  Mummpikia                  = pal[5],
  Lingula                         = pal[5],
  Eoobolus                        = pal[5],
  Clupeafumosus_socialis          = 'grey',
  Clupeafumosus          = 'grey',
  Phoronis                        = pal[1],
  Dailyatia                       = pal[1],
  Eccentrotheca                   = pal[1],
  Yuganotheca_elegans             = 'grey',
  Yuganotheca             = 'grey',
  Longtancunella_chengjiangensis  = 'grey',
  Longtancunella  = 'grey',
  Paterimitra                     = pal[1],
  Lingulellotreta_malongensis     = pal[2],
  Lingulellotreta     = pal[2],
  Acanthotretella                 = pal[2],
  Lingulosacculus                 = pal[2],
  Pedunculotheca_diania           = pal[2],
  Pedunculotheca           = pal[2],
  Haplophrentis_carinatus         = pal[2],
  Haplophrentis         = pal[2],
  Tomteluva_perturbata            = 'grey',
  Tomteluva            = 'grey',
  Salanygolina                    = pal[9],
  Coolinia_pecten                 = pal[9],
  Coolinia                 = pal[9],
  Antigonambonites_planus         = pal[9],
  Antigonambonites         = pal[9],
  Kutorgina_chengjiangensis       = pal[10],
  Kutorgina       = pal[10],
  Nisusia_sulcata                 = pal[10],
  Nisusia                 = pal[10],
  Alisina                         = pal[11],
  Glyptoria                       = pal[11],
  Orthis                          = pal[11],
  Terebratulina                   = pal[11])


ColPlot <- function (tree) {
  setPar()
  plot(tree, tip.color = tipCol[tree$tip.label], lwd=2)
}
ColMissing <- function (omit) MarkMissing(omit, text.font=3, cex=0.8,
                                          text.col=tipCol[omit])
```

# Brachiopod origins {-}

This document provides a detailed discussion of analyses of the [morphological dataset](#dataset) constructed to accompany Sun _et al._ [-@Sun2018], and their results.

We first discuss the results presented in the main paper, which employ the algorithm described by Brazeau, Guillerme and Smith [-@Brazeau2018] for correct handling of inapplicable data in a parsimony setting, and explore how each
character is [reconstructed](#reconstructions) on an optimal tree.

For completeness, we also document the results of [standard Fitch parsimony](#tnt) analysis, and the results of [Bayesian analysis](#MrBayes), neither of which treat inapplicable data in a logically consistent fashion.

<!--chapter:end:index.Rmd-->

---
title: "Phylogenetic dataset"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# The dataset

Analysis was performed on a new matrix of `r length(names(my_data)) - 1L` early brachiozoan taxa, including hyoliths, tommotiids and mickwitziids, which were coded for `r sum(attr(my_data, 'weight'))` morphological characters (`r sum(neomorphic)` neomorphic, `r sum(!neomorphic)` transformational).

The dataset can be viewed and downloaded at Morphobank ([project 2800](https://morphobank.org/permalink/?P2800)), where each character is defined
and its coding for each taxon discussed.

Characters are coded following the recommendations of Brazeau, Guillerme and
Smith [@Brazeau2018].  In brief, we have employed reductive coding, using a distinct state to mark character inapplicability. Character specifications follow the model of Sereno [-@Sereno2007].

We have distinguished between neomorphic and transformational characters [sensu @Sereno2007] by reserving the token `0` to refer to the absence of a neomorphic character.  The states of transformational characters are represented by the tokens `1`, `2`, `3`, ...

Following the recommendations of Brazeau, Guillerme and
Smith [@Brazeau2018, supplementary discussion], we code the absence of neomorphic ontologically dependent characters [sensu @Vogt2017] as absence, rather than inapplicability.


<!--chapter:end:01_Dataset.Rmd-->

---
title: "TreeSearch results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# Parsimony analysis {#treesearch}

The phylogenetic dataset contains a high proportion of inapplicable codings (`r sum(my_chars == '-')`/ `r length(my_chars)` = `r round(sum(my_chars == '-') / length(my_chars), 2) * 100`% of tokens), which are known to introduce error and bias to phylogenetic reconstruction ([@Maddison1993;@Brazeau2018]).  As such, phylogenetic search employed a new algorithm that correctly handles inapplicable data [@Brazeau2018].  This algorithm is implemented in the _MorphyLib_ C library [@Brazeau2017Morphylib], and phylogenetic search was conducted using the _R_ package _TreeSearch_ v0.0.8 [@Smith2018TreeSearch].

_Namacalathus_ is included in the matrix but has been excluded from analysis due to its potentially long branch, which is likely to mislead analysis.

## Search parameters

Heuristic searches were conducted using the parsimony ratchet [@Nixon1999] under equal and implied weights [@Goloboff1997] with a variety of concavity constants.  The consensus tree presented in the main manuscript represents a strict consensus of all trees that are most parsimonious under one or more of the concavity constants (_k_) 2, 3, 4.5, 7, 10.5, 16 and 24, an approach that is known to produce higher accuracy than equal weights at any fixed level of precision [@Smith2017].

## Analysis 

### Load data

```{r TS Load morphoBank, echo=FALSE}
# Load file from MorphoBank
my_data <- ReadAsPhyDat(filename)
my_data$Namacalathus <- NULL # Exclude Namacalathus

iw_data <- PrepareDataIW(my_data)
kValues <- c(2, 3, 4.5, 7, 10.5, 16, 24)
```

### Generate starting tree

_Dailyatia_ is used as an outgroup.

```{R Starting tree, cache=TRUE}
nj.tree <- NJTree(my_data)
rooted.tree <- EnforceOutgroup(nj.tree, 'Dailyatia')
start.tree <- TreeSearch(tree=rooted.tree, dataset=my_data, maxIter=3000,
                         EdgeSwapper=RootedNNISwap, verbosity=0)
```

### Implied weights analysis

```{r Implied weights analysis in TreeSearch, cache=TRUE, eval=FALSE}
for (k in kValues) {
  iw.tree <- IWRatchet(start.tree, iw_data, concavity=k,
                       ratchHits = 60, searchHits=55,
                       swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap),
                       verbosity=0)
  score <- IWScore(iw.tree, iw_data, concavity=k)
  # Write single best tree
  write.nexus(iw.tree, file=paste0("TreeSearch/hy_iw_k", k, "_", signif(score, 5), ".nex", collapse=''))

  suboptFraction = 0.02
  iw.consensus <- IWRatchetConsensus(iw.tree, iw_data, concavity=k,
                  swappers=list(RootedTBRSwap, RootedNNISwap),
                  searchHits=4,
                  suboptimal=score * suboptFraction,
                  nSearch=150, verbosity=0L)
  write.nexus(iw.consensus, file=paste0("TreeSearch/hy_iw_k", k, "_", signif(IWScore(iw.tree, iw_data, concavity=k), 3), ".all.nex", collapse=''))
}
```

### Equal weights analysis

```{r Equal weights analysis in TreeSearch, cache=TRUE, eval=FALSE}
ew.tree <- Ratchet(start.tree, my_data, verbosity=0L,
                   ratchHits = 10, searchHits=55,
                   swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap))
write.nexus(best.tree, file=paste0("TreeSearch/hy_ew_", Fitch(ew.tree, my_data), ".nex", collapse=''))

ew.consensus <- RatchetConsensus(ew.tree, my_data, nSearch=150,
                                 swappers=list(RootedTBRSwap, RootedNNISwap),
                                 verbosity=0L)
write.nexus(ew.consensus, file=paste0("TreeSearch/hy_ew_", Fitch(ew.tree, my_data), ".nex", collapse=''))
```

## Results

### Implied weights results

```{R "Load IW trees TreeSearch"}
# Read results from files
iw.trees <- lapply(kValues, function (k) {
  iw.best <- list.files('TreeSearch', 
                      pattern=paste0('hy_iw_k',
                                     gsub('\\.', '\\\\.', k),
                                     '_\\d+\\.?\\d*\\.all\\.nex'),
                      full.names=TRUE)
  # Return:
  if (length(iw.best) == 0) {
    list()
  } else {
    read.nexus(iw.best[which.max(file.mtime(iw.best))])
  }
})
```



```{r, fig.cap="Consensus of implied weights analyses at all values of k", fig.width=6, fig.height=5}
omit=c(lon, 'Clupeafumosus_socialis',
       'Heliomedusa_orienta', 'Haplophrentis_carinatus')
ColPlot(ConsensusWithout(lapply(iw.trees, consensus), omit))
ColMissing(omit)
```



```{r, fig.cap="Implied weights results", fig.width=7.1, fig.height=10.5}
# Plot consensus results
par(mfrow=c(4, 2), mar=rep(0.2, 4))

ColPlot(consensus(lapply(iw.trees, consensus)))
text(-0.5, 1, pos=4, "Consensus of all k values", cex=0.8)

# Plot results for each value of k
for (i in seq_along(iw.trees)) {
  ColPlot(consensus(iw.trees[[i]]))
  text(1, 1, paste0('k = ', kValues[i]), pos=4)
}

```

### Equal weights results

```{r "equal weights results in TreeSearch", fig.cap="Strict consensus of equal weights results"}
ew.best <- list.files('TreeSearch', pattern='hy_ew_\\d*\\.nex', full.names=TRUE)
ew.tree <- read.nexus(file=ew.best[which.max(file.mtime(ew.best))])
ColPlot(consensus(ew.tree))
```

```{R, fig.cap="Strict consensus of equal weights results, taxa excluded"}
omit <- c(lon)
ColPlot(ConsensusWithout(ew.tree, omit))
ColMissing(omit)
```

<!--chapter:end:02_TreeSearch.Rmd-->

---
title: "Visualizing characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---

# Character reconstructions {#reconstructions}

Here's how each character maps onto one of the most parsimonious trees (obtained under implied weighting, $k = 4.5$):

```{R, echo=FALSE, fig.height=6.6, fig.width=7.1}
library('Inapp')
tree <- iw.trees[[3]][[1]]
tree$edge.length <- rep(1, nrow(tree$edge))
#treeCol <- tipCol[tree$tip.label]

for (i in seq_len(ncol(my_chars))) {
  par(mar=rep(0.2, 4), cex=0.7, oma=c(1.2, 0, 1.2, 0))
  
  plot.states.matrix(apply.reconstruction(tree, my_chars[, i],
                                          match.tip.char=TRUE),
                     passes=0, counts=1:2, show.labels=1,
                     col.states=TRUE, state.labels=my_states[[i]],
                     #tip.col=treeCol, 
                     use.edge.length=TRUE, legend.pos='topright')
  
  mtext(paste("Character", i, "-", colnames(my_chars)[i]),
        c(1, 3), outer=TRUE, cex=0.8)
}
```

These reconstructions were created using the _Inapp_ _R_ package [@Brazeau2018].

Full character definitions can be found by browsing the [morphological dataset](#dataset) on MorphoBank ([project 2800](https://morphobank.org/permalink/?P2800)).

<!--chapter:end:03_Characters.Rmd-->

---
title: "Standard (Fitch) parsimony results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---


# Fitch parsimony {#tnt}

Parsimony search was conducted in TNT v1.5 [@Goloboff2016] using sectorial and ratchet heuristics under equal and implied weights.  We acknowledge the Willi Hennig Society for their sponsorship of the TNT software.

```{R, echo=FALSE}
tntFiles <- list.files('TNT/', pattern='xpiwe.*\\.tre', full=TRUE)
filename <- tntFiles[1]
tnTrees <- lapply(tntFiles, ReadTntTree)
```

## Implied weights

The consensus of all implied weights runs is not very well resolved:

```{R, echo=FALSE, fig.wid=7.1, fig.height=10}
setPar()
par(mfrow=c(1, 2))
ColPlot(consensus(tnTrees)) 
text(1, 0.5, 'Consensus of all k values', pos=4, cex=0.6)

for (i in 1:7) {
  ColPlot(tnTrees[[i]])
  text(1, 0.5, paste('k =', kValues[i]), pos=4, cex=0.6)
}

```

This lack of resolution is largely a product of a few wildcard taxa, which obscure relationships that are nevertheless present in all most parsimonious trees:

### Paterinids included

```{R, echo=FALSE, fig.cap="TNT implied weights consensus"}
omit <- c('Clupeafumosus_socialis', 'Micrina', 'Mickwitzia_muralensis', 'Paterimitra', 'Heliomedusa_orienta', 'Tomteluva_perturbata', 'Yuganotheca_elegans', 'Salanygolina', 'Gasconsia', 'Mummpikia_nuda')
ColPlot(ConsensusWithout(tnTrees, omit))
ColMissing(omit)
```

### Paterinids excluded

```{R, echo=FALSE, fig.cap="TNT implied weights consensus"}
omit <- c('Clupeafumosus_socialis', 'Micrina', 'Mickwitzia_muralensis', 'Paterimitra', 'Heliomedusa_orienta', 'Tomteluva_perturbata', 'Yuganotheca_elegans', 'Salanygolina', 'Gasconsia', 'Mummpikia_nuda', 'Kutorgina_chengjiangensis', 'Nisusia_sulcata')
ColPlot(ConsensusWithout(tnTrees, omit))
ColMissing(omit)
```


## Equal weights

```{R, echo=FALSE, fig.cap="TNT Equal weights consensus"}
tntEw <- list.files('TNT/', pattern='ew\\.tre', full=TRUE)
ColPlot(ConsensusWithout(ReadTntTree(tntEw), lon))
ColMissing(lon)
```

<!--chapter:end:04_TNT.Rmd-->

---
title: "Bayesian Analysis results"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
bibliography: [References.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
output:
  html_document: default
  pdf_document: default
---


# Bayesian analysis

```{R, echo=FALSE}
files <- list.files('MrBayes', pattern='^hyo\\..*\\.t$', full.names=TRUE)

allTrees <- lapply(files, read.nexus)
nTrees <- length(allTrees[[1]])

postBurnin <- lapply(allTrees, function (x) x[ceiling(nTrees * 0.1):nTrees])
```

Bayesian search was conducted in MrBayes v3.2.6 [@Ronquist2012] using the Mk model [@Lewis2001] with a gamma parameter:

> lset coding=variable rates=gamma;

Branch length was drawn from a dirichlet prior distribution, which is less informative than an exponential model [@Rannala2012], but requires a prior mean tree length within about two orders of magnitude of the true value [@Zhang2012]. To satisfy this latter criterion, we specified the prior mean tree length to be equal to the length of the most parsimonious tree under equal weights, usinga Dirichlet prior with $α_T = 1$, $β_T = 1/$(_equal weights tree length_ / _number of characters_), $α = c = 1$:

> prset brlenspr = unconstrained: gammadir(1, 0.33, 1, 1);

Neomorphic and transformational characters [sensu @Sereno2007] were allocated to two separate partitions whose proportion of invariant characters and gamma shape parameters were allowed to vary independently:

> charset Neomorphic = `r paste(which(neomorphic), collapse=' ')`;
>
> charset Transformational = `r paste(which(!neomorphic), collapse=' ')`;
>
>
> partition chartype = 2: Neomorphic, Transformational;
>
> set partition = chartype;
>
>
> unlink shape=(all) pinvar=(all);


Neomorphic characters were not assumed to have a symmetrical transition rate – that is, the probability of the absent → present transition was allowed to differ from that of the present → absent transition, being drawn from a uniform prior:

> prset applyto=(1) symdirihyperpr=fixed(1.0);

Four MrBayes runs were executed, each sampling eight chains for 1 000 000 generations, with samples taken every 500 generations:

> mcmcp ngen=1000000 samplefreq=500 nruns=2 nchains=8;

The first 10% of samples were discarded as burn-in (`burninfrac=0.1`), and a posterior tree topology was derived from the combined posterior sample of both runs.

```{R, echo=FALSE, fig.cap="Bayesian analysis, posterior probability > 50%"}
omit <- c('Clupeafumosus', 'Heliomedusa')
 # 'Novocrania', 'Craniops', 'Ussunia', 'Gasconsia',
thinned <- c(lapply(postBurnin[[1]], drop.tip, omit),
             lapply(postBurnin[[2]], drop.tip, omit),
             lapply(postBurnin[[3]], drop.tip, omit),
             lapply(postBurnin[[4]], drop.tip, omit))
class(thinned) <- 'multiPhylo'
ColPlot(consensus(thinned, p=0.5))
ColMissing(omit)
```

```{R, echo=FALSE, fig.cap="Bayesian analysis, posterior probability > 50%"}
omit <- c('Heliomedusa', 'Micrina', 'Mickwitzia',
          'Eoobolus', 'Clupeafumosus', 
          'Yuganotheca', 'Longtancunella', 'Tomteluva', 'Nisusia', 'Kutorgina')
 # 'Novocrania', 'Craniops', 'Ussunia', 'Gasconsia',
thinned <- c(lapply(postBurnin[[1]], drop.tip, omit),
             lapply(postBurnin[[2]], drop.tip, omit),
             lapply(postBurnin[[3]], drop.tip, omit),
             lapply(postBurnin[[4]], drop.tip, omit))
class(thinned) <- 'multiPhylo'
ColPlot(consensus(thinned, p=0.5))
ColMissing(omit)
```

Convergence was indicated by PSRF = 1.00 and an average estimated sample size of > 500 for each parameter:

```{R, MrBayes parameter summary, echo=FALSE, asis=TRUE}
knitr::kable(read.table ('MrBayes/hyo.nex.pstat', skip=1, header=TRUE),
             caption="MrBayes parameter estimates (.pstat file)")
```

It's interesting to note that the clade of hyolliths + lingulellotretids (+ relatives) is resolved as a grade under Bayesian analysis.  

In parsimony analysis, these taxa are always resolved as a clade when inapplicable data is correctly handled; they instead resolve as a grade under certain conditions under the [standard Fitch](#TNT) algorithm (which mishandles inapplicable data). 

We suggest that the failure of Bayesian analysis to recover this group as a clade may reflect inappropriate handling of inapplicable data in MrBayes, though at present (and until the algorithms used in a likelihood context are improved) it is difficult to test this hypothesis.

<!--chapter:end:05_MrBayes.Rmd-->

