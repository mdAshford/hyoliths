---
title: "Visualizing characters"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
---

# Character reconstructions {#reconstructions}

This page provides definitions for each of the characters in our matrix, and justifies codings in particular taxa where relevant.  Further citations for codings that are not discussed in the text can be viewed by browsing the [morphological dataset](#dataset) on MorphoBank ([project 2800](https://morphobank.org/permalink/?P2800)). <mark>This link will become live on publication of the paper. Referees should follow the pre-publication link to the dataset that has been provided in the main manuscript.</mark>

Alongside each character's definition, we have shown how the character maps onto one of the most parsimonious trees (obtained under implied weighting, $k = 4.5$).  Each tip is labelled as it is coded in the matrix, and these states are used to reconstruct the condition of each internal node, using the parsimony method of @Brazeau2018 as implemented in the _Inapp_ _R_ package.

We emphasize that this is only one most parsimonious tree, selected arbitrarily.  Different trees will give different reconstructions.  The character mappings are not intended to definitively establish how each character evolved, but to help the reader quickly establish how each character has been coded, and to visualize at a glance how well the character fits onto the given tree.  We consider this more intuitive than the use of the flawed [@Archie1989] Consistency Index, but include this value because of its historic significance.

We judge that the reader would be overwhelmed if presented with every possible MPT, and that detail would be lost if characters were only displayed on a consensus tree.  We refer the reader back to the [results][#treesearch] that they may evaluate how the tree presented compares to the consensus tree obtained under their preferred analytical parameters.


```{R char loading functions, echo=FALSE}
StrReplace <- stringi::stri_replace_all_fixed

LookUpReference <- function (keys, original, prefix='', suffix='') {
  keyParts <- "^~~~(.+?)(\\b.*)~~~$"
  keySuffixes <- gsub(keyParts, "\\2", keys, perl=TRUE)
  keys <- gsub(keyParts, "\\1", keys, perl=TRUE)
  if (length(keys) == 0) {
    return (character(0))
  } else if (length(keys) == 1) {
    matches <- grepl(keys, refKeys, fixed=TRUE)
    if (sum(matches) == 1) {
      paste0(prefix, refKeys[matches], keySuffixes, suffix)
    } else {
      paste0('<mark>', original, '</mark>')
    }
  } else { # length(keys) > 1
     # initialize
    ret <- paste0('<mark>', original, '</mark>')
    if (length(suffix) == 1) suffix <- rep(suffix, length(keys))
    if (length(prefix) == 1) prefix <- rep(prefix, length(keys))
    
    matches <- vapply(keys, FUN=grepl, FUN.VALUE=logical(length(refKeys)), refKeys, fixed=TRUE)
    uniques <- colSums(matches) == 1
    ret[uniques] <- vapply(which(uniques), function (i) 
      paste0(prefix[i], refKeys[matches[, i]], keySuffixes[i], suffix[i])
      , character(1))
    
    # Return:
    ret
  }
}

ConvertReferences <- function (string) {
  noParentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)?,? (\\d\\d\\d\\d\\w?)\\b"
  ReplNoPar <- function (keyedText, oldKey, original) {
    StrReplace(keyedText, oldKey,
                LookUpReference(oldKey, original, prefix='@'),
               vectorize_all=FALSE)
  }
  
  parentheses <- "([A-Z][A-z]+)( et al\\.| ?(?:&|and) ?\\w+)?,? \\((\\d\\d\\d\\d\\w?)\\b([^\\)]*)\\)"
  ReplPar <- function (keyedText, oldKey, original) {
    StrReplace(keyedText, oldKey,
                LookUpReference(oldKey, original, 
                  prefix=paste0(gsub(parentheses, "\\1\\2", original, perl=TRUE), ' [-@'),
                  suffix=']'
                ), vectorize_all=FALSE)
                
  }
  
  ReplaceRefs <- function (pattern, strings, Replace) {
    execResults <- gregexpr(pattern, strings, perl=TRUE)
    matchText <- lapply(regmatches(strings, execResults), unique)
    keyed <- gsub(pattern, "~~~\\1\\3\\4~~~", strings, perl=TRUE)
    keys <- lapply(matchText, function (citation) {
      ret <- gsub(pattern, "~~~\\1\\3\\4~~~", citation, perl=TRUE)
      duplicates <- ret[duplicated(ret)]
      substr(ret[duplicated(ret)], nchar(duplicates)-6, nchar(duplicates)-3) <- '!x2!'
      ret
    })
    toEdit <- which(vapply(keys, length, 0) > 0)
    strings[toEdit] <- vapply(toEdit, function (i) {
      Replace(keyed[i], keys[[i]], matchText[[i]])
    }, character(1))
    # Return:
    strings
  }
  
  matches <- grepl(noParentheses, string)
  string[matches] <- ReplaceRefs(noParentheses, string[matches], ReplNoPar)
  
  matches <- grepl(parentheses, string)
  string[matches] <- ReplaceRefs(parentheses, string[matches], ReplPar)
  
  string <- gsub("\\(([^\\)]*?@\\S+?[^\\)]*)\\)", "[\\1]", string, perl=TRUE)
  
  # Return:
  string
}

MorphoBankDecode <- function (string) {
  string <- gsub("^n", "  \n", string, fixed=TRUE)
  string <- gsub("''", "'", string, fixed=TRUE)
  string <- gsub(" - ", " -- ", string, fixed=TRUE)
  string <- gsub("(\\d)\\-(\\d)", "\\1--\\2", string, perl=TRUE)
  string <- gsub("(\\d) ?um\\b", "\\1 Âµm", string, perl=TRUE)
  string <- gsub(" et al ", " et al. ", string, fixed=TRUE)
  string <- gsub(" et alia", " et al.", string, fixed=TRUE)
  
  # Return:
  ConvertReferences(string)
}

EndSentence <- function (string) {
  ret <- gsub("\\s*\\.?\\s*\\.$", ".", paste0(string, '.'), perl=TRUE)
  ret <- gsub("(\\.[\"'])\\.$", "\\1", ret, perl=TRUE)
}

ReadNotes <- function (filepath) {
  lines <- enc2utf8(readLines(filepath))
  charNote.pattern <- "^\\s+TEXT\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  stateNote.pattern <- "^\\s+TEXT\\s+TAXON=(\\d+)\\s+CHARACTER=(\\d+)\\s+TEXT='(.*)';\\s*$"
  upperLines <- toupper(lines)
  notesStart <- which(upperLines == "BEGIN NOTES;")
  endBlocks <- which(upperLines == "ENDBLOCK;")
  if (length(notesStart) == 0) {
    return(list("NOTES block not found in Nexus file."))
  } else if (length(notesStart) > 1) {
    return(list("Multiple NOTES blocks found in Nexus file."))
  } else {
    notesEnd <- endBlocks[endBlocks > notesStart][1] - 1L
    notesLines <- lines[(notesStart + 1):notesEnd]
    charNote.matches <- grepl(charNote.pattern, notesLines, perl=TRUE)
    charNotes <- gsub(charNote.pattern, "\\2",
                       notesLines[charNote.matches], perl=TRUE)
    charNotes <- EndSentence(MorphoBankDecode(charNotes))
    charNumbers <- gsub(charNote.pattern, "\\1",
                              notesLines[charNote.matches], perl=TRUE)
    
    stateNote.matches <- grepl(stateNote.pattern, notesLines, perl=TRUE)
    stateNotes <- gsub(stateNote.pattern, "\\3",
                       notesLines[stateNote.matches], perl=TRUE)
    stateNotes <- EndSentence(MorphoBankDecode(stateNotes))
    stateTaxon <- gsub(stateNote.pattern, "\\1",
                              notesLines[stateNote.matches], perl=TRUE)
    stateChar  <- gsub(stateNote.pattern, "\\2",
                              notesLines[stateNote.matches], perl=TRUE)
    
    seqAlongNotes <- seq_len(max(as.integer(c(stateChar, charNumbers))))
    charNotes <- lapply(seqAlongNotes, function (i) {
      ret <- list(
        charNotes[charNumbers == i],
        stateNotes[stateChar == i])
      names(ret[[2]]) <- stateTaxon[stateChar == i]
      
      # Return:
      ret
    })
    names(charNotes) <- seqAlongNotes
    
    # Return:
    charNotes
  }
}

PrintStates <- function (states) {
  states <- gsub("^'(.*)'$", "\\1", states)
  tokens <- seq_along(states) - 1L
  if (states[1] == "") {
    states <- states[-1]
    tokens <- tokens[-1]
    transformational <- TRUE
  } else {
    transformational <- FALSE
  }
  cat(paste0(" > ", tokens, ": ", states, "  \n"))
  cat("> ", if (transformational) "Transformational" else "Neomorphic", "character.  \n>\n")
}


Italicize <- function (string) {
  string <- gsub(paste0("\\b(", 
                        paste0(gsub("_", "|", fixed = TRUE,
                                    c(taxa_names,
                                      'Bethia', 'Discinisca', 
                                      'Eichwaldia', 'Eoorthis',
                                      'Hadrotreta', 'Kraussina',
                                      'Lochkothele', 'Neocrania',
                                      'Paracraniops', 'Paramicrocornus',
                                      'Phoronopsis',
                                      'comleyensis', 'decaius',
                                      'schucherti', 'tenuis', 'worsleyi',
                                      'vascula', 'genitalia','lateralia',
                                      'media', 'myaria', 'terminalia',
                                      'levator ani',
                                      'et al\\.', 'et al', 'sensu')),
                               collapse='|'),
              ")\\b"), "_\\1_", string, perl=TRUE, ignore.case=FALSE)
  gsub("\\b([A-Z]\\.) _([a-z])", "_\\1 \\2", string, perl=TRUE)
}
```
```{R load-the-characters, echo=FALSE, message=FALSE}
if (!require('Inapp')) devtools::install_github('TGuillerme/Inapp')
library('Inapp')
tree <- iw.trees[[3]][[2]]
#tree <- ew.trees[[1]]
tree$edge.length <- rep(1, nrow(tree$edge))
tree_labels <- tree$tip.label

char_names <- gsub("^'(.+)'$", "\\1", colnames(my_chars))
n_char <- ncol(my_chars)
char_parts <- strsplit(char_names, ": ")
char_nesting <- vapply(char_parts, length, 0L)
char_notes <- ReadNotes(filename)
taxa_names <- c("Namacalathus", rownames(my_chars))
taxa_sort <- taxa_names
taxa_plaintext <- gsub("_", " ", taxa_names, fixed=TRUE)
taxa_italic <- paste0("_", taxa_plaintext, "_")

fitch_consistency_index <- CI(tree, my_data, sitewise=TRUE)
fitch_steps <- fitch(tree, my_data, site='site')[attr(my_data, 'index')]
min_steps <- fitch_consistency_index * fitch_steps
# Maximum steps is tricky to calculate, so we'll leave RI [= max-obs / max-min]
# unless referees insist on it; neither it nor CI mean much in any case.
fitch_retention_index <- RI(tree, my_data, sitewise=TRUE)
RetentionIndex <- function (i) {
  if (retention_index[i] == 'NaN') 'n/a' else signif(retention_index[i], 2)
}

```
```{R character-mapping, echo=FALSE, fig.height=6.2, fig.width=7.1, results="asis"}
## These function definitions must be in the same block as when they are called.
Header <- function (level, content) paste0("  \n", paste0(rep('#', level), collapse=''), " ", content, "  \n")
PrintDivision <- function (parts) cat(Header(2L, paste(
  Italicize(this_char_parts[1:parts]), collapse=': ')))
PrintCharacter <- function () {
  cat(Header(3L, paste0("[", i, "] ", paste0(Italicize(
    this_char_parts[if(char_nesting[i] < 4) char_nesting[i] else 3:char_nesting[i]]),
    collapse=': '), " {-}")))
}
PrintSoloCharacter <- function () {
  cat(Header(2L, paste0(paste(
    Italicize(this_char_parts), collapse=': ')," [", i, "] ")))
}
DuplicateOf <- function (x) {
  duplicates <- duplicated(x)
  masters <- x[!duplicates]
  vapply(masters, function (d) x == d, logical(length(x)))
}
PrintStateNotes <- function (notes) {
  PrintThisNote <- function (note) {
    afflictedTaxa <- names(note)[note]
    master <- afflictedTaxa[1]
    cat("  \n",
        paste0("<div class='state-note' id='",
                     taxa_names[as.integer(master)], "-coding-", i,
                     "'>",
               paste(taxa_italic[as.integer(afflictedTaxa)], collapse=', '),
                      ": ", Italicize(notes[master]), "</div>  \n  \n"))
  }
  
  if (length(notes) == 1) {
    onlyOne <- TRUE
    names(onlyOne) <- names(notes)
    PrintThisNote(onlyOne)
  } else {
    notes <- notes[order(taxa_sort[as.integer(names(notes))])]
    duplicates <- DuplicateOf(toupper(notes))
    apply(duplicates, 2, PrintThisNote)
  }
}

taxa_not_to_print <- which(taxa_names %in% 'Namacalathus')
prev_char_parts = "NONE"
prev_nesting = 0
for (i in seq_len(n_char)) {
  
  this_char_parts <- char_parts[[i]]
  next_char_parts <- if (i == n_char) "LAST_CHARACTER" else char_parts[[i + 1L]]
  this_nesting <- char_nesting[i]
  next_nesting    <- if (i == n_char) 0 else char_nesting[i + 1L]
  
  if ( # Reasons to print a heading
    (this_char_parts[1] != prev_char_parts[1]) ||
    ( this_nesting > 1L && prev_nesting > 2L &&
      this_char_parts[2] != prev_char_parts[2]) ||
    ( this_nesting > 1L && prev_nesting > 1L && next_nesting > 2L &&
      this_char_parts[2] == next_char_parts[2] &&
      this_char_parts[2] != prev_char_parts[2])
  ) {
    if ( # Reasons to print a Solo character
      (this_char_parts[1] != next_char_parts[1] && 
       this_char_parts[1] != prev_char_parts[1]) ||
      (this_nesting == 2L && next_nesting > 1L &&
       prev_char_parts[1] == this_char_parts[1] &&
       next_char_parts[1] == this_char_parts[1]) ||
      (this_nesting == 1L && next_nesting > 1L &&
            next_char_parts[1] == this_char_parts[1]) ||
      prev_nesting > 2L && (
        next_nesting < 2L
        || (this_nesting > 1L && next_nesting > 2L && 
            (this_char_parts[2] != next_char_parts[2]))
      )
    ) {
      PrintSoloCharacter()
    }
    else if ( # Reasons to print a top-level heading
      this_nesting == 1 ||
      (next_nesting > 1 && (this_char_parts[2] != next_char_parts[2]))
    ) {
      PrintDivision(1)
      PrintCharacter()
    } else {
      PrintDivision(2)
      PrintCharacter()
    }
  } else { # Just print the character
    PrintCharacter()
  }
  prev_char_parts <- this_char_parts
  prev_nesting <- char_nesting[i]
  
  par(mar=rep(0.2, 4), cex=0.7)
  
  character_reconstruction <- apply.reconstruction(tree, my_chars[, i])
  plot.states.matrix(character_reconstruction,
                     passes=0, counts=1:2, show.labels=1,
                     col.states=TRUE, state.labels=my_states[[i]],
                     use.edge.length=TRUE, legend.pos='topright')
  legend('bottomleft', paste0('CI = ', 
                              signif(min_steps[i] / character_reconstruction$score, 2),
                              '; Fitch CI = ', fitch_consistency_index[i],
                              '; Fitch RI = ', RetentionIndex(i)))
  
  cat(paste0("  \n\n **Character ", i, ": ", Italicize(char_names[i]), "**  \n\n"))
  PrintStates(Italicize(my_states[[i]]))
  cat("  \n\n")
  char_notes_i <- char_notes[[i]]
  state_notes_i <- char_notes_i[[2]]
  state_notes_i <- state_notes_i[!names(state_notes_i) %in% taxa_not_to_print]
  if (length(char_notes_i[[1]]) > 0) cat(Italicize(char_notes_i[[1]]), "  \n")
  if (length(state_notes_i) > 0) PrintStateNotes(state_notes_i)
  cat("  \n") # Clear line, ready for next block
}
```
