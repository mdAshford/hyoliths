[
["index.html", "Brachiopod origins - Supplementary material - Phylogenetic analysis Brachiopod origins", " Brachiopod origins - Supplementary material - Phylogenetic analysis Sun, Hai-Jing; Smith, Martin Ross; Zhu, Mao-Yan; Zeng, Han; Zhao, Fang-Chen 2018-03-13 Brachiopod origins This document provides a detailed discussion of analyses of the morphological dataset constructed to accompany Sun et al. (2018), and their results. We first discuss the results presented in the main paper, which employ the algorithm described by Brazeau, Guillerme and Smith (2017) for correct handling of inapplicable data in a parsimony setting, and explore how each character is reconstructed on an optimal tree. For completeness, we also document the results of standard Fitch parsimony analysis, and the results of Bayesian analysis, neither of which treat inapplicable data in a logically consistent fashion. References "],
["the-dataset.html", "1 The dataset", " 1 The dataset Analysis was performed on a new matrix of 35 early brachiozoan taxa, including hyoliths, tommotiids and mickwitziids, which were coded for 95 morphological characters (42 neomorphic, 53 transformational). The dataset can be viewed and downloaded at Morphobank (project 2800), where each character is defined and its coding for each taxon discussed. Characters are coded following the recommendations of Brazeau, Guillerme and Smith (Brazeau et al., 2017). In brief, we have employed reductive coding, using a distinct state to mark character inapplicability. Character specifications follow the model of Sereno (2007). We have distinguished between neomorphic and transformational characters (sensu Sereno, 2007) by reserving the token 0 to refer to the absence of a neomorphic character. The states of transformational characters are represented by the tokens 1, 2, 3, … Following the recommendations of Brazeau, Guillerme and Smith (Brazeau et al., 2017, supplementary discussion), we code the absence of neomorphic ontologically dependent characters (sensu Vogt, 2017) as absence, rather than inapplicability. References "],
["treesearch.html", "2 Parsimony analysis 2.1 Search parameters 2.2 Analysis 2.3 Results", " 2 Parsimony analysis The phylogenetic dataset contains a high proportion of inapplicable codings (404/ 3325 = 12% of tokens), which are known to introduce error and bias to phylogenetic reconstruction ((Brazeau et al., 2017; Maddison, 1993)). As such, phylogenetic search employed a new algorithm that correctly handles inapplicable data (Brazeau et al., 2017). This algorithm is implemented in the MorphyLib C library (Brazeau, Smith, &amp; Guillerme, 2017), and phylogenetic search was conducted using the R package TreeSearch v0.0.8 (Smith, 2018). Namacalathus is included in the matrix but has been excluded from analysis due to its potentially long branch, which is likely to mislead analysis. 2.1 Search parameters Heuristic searches were conducted using the parsimony ratchet (Nixon, 1999) under equal and implied weights (Pablo A. Goloboff, 1997) with a variety of concavity constants. The consensus tree presented in the main manuscript represents a strict consensus of all trees that are most parsimonious under one or more of the concavity constants (k) 2, 3, 4.5, 7, 10.5, 16 and 24, an approach that is known to produce higher accuracy than equal weights at any fixed level of precision (Smith, 2017). 2.2 Analysis 2.2.1 Load data 2.2.2 Generate starting tree Dailyatia is used as an outgroup. nj.tree &lt;- NJTree(my_data) rooted.tree &lt;- EnforceOutgroup(nj.tree, &#39;Dailyatia&#39;) start.tree &lt;- TreeSearch(tree=rooted.tree, dataset=my_data, maxIter=3000, EdgeSwapper=RootedNNISwap, verbosity=0) 2.2.3 Implied weights analysis for (k in kValues) { iw.tree &lt;- IWRatchet(start.tree, iw_data, concavity=k, ratchHits = 60, searchHits=55, swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap), verbosity=0) score &lt;- IWScore(iw.tree, iw_data, concavity=k) # Write single best tree write.nexus(iw.tree, file=paste0(&quot;TreeSearch/hy_iw_k&quot;, k, &quot;_&quot;, signif(score, 5), &quot;.nex&quot;, collapse=&#39;&#39;)) suboptFraction = 0.02 iw.consensus &lt;- IWRatchetConsensus(iw.tree, iw_data, concavity=k, swappers=list(RootedTBRSwap, RootedNNISwap), searchHits=4, suboptimal=score * suboptFraction, nSearch=150, verbosity=0L) write.nexus(iw.consensus, file=paste0(&quot;TreeSearch/hy_iw_k&quot;, k, &quot;_&quot;, signif(IWScore(iw.tree, iw_data, concavity=k), 3), &quot;.all.nex&quot;, collapse=&#39;&#39;)) } 2.2.4 Equal weights analysis ew.tree &lt;- Ratchet(start.tree, my_data, verbosity=0L, ratchHits = 10, searchHits=55, swappers=list(RootedTBRSwap, RootedSPRSwap, RootedNNISwap)) write.nexus(best.tree, file=paste0(&quot;TreeSearch/hy_ew_&quot;, Fitch(ew.tree, my_data), &quot;.nex&quot;, collapse=&#39;&#39;)) ew.consensus &lt;- RatchetConsensus(ew.tree, my_data, nSearch=150, swappers=list(RootedTBRSwap, RootedNNISwap), verbosity=0L) write.nexus(ew.consensus, file=paste0(&quot;TreeSearch/hy_ew_&quot;, Fitch(ew.tree, my_data), &quot;.nex&quot;, collapse=&#39;&#39;)) 2.3 Results 2.3.1 Implied weights results # Read results from files iw.trees &lt;- lapply(kValues, function (k) { iw.best &lt;- list.files(&#39;TreeSearch&#39;, pattern=paste0(&#39;hy_iw_k&#39;, gsub(&#39;\\\\.&#39;, &#39;\\\\\\\\.&#39;, k), &#39;_\\\\d+\\\\.?\\\\d*\\\\.all\\\\.nex&#39;), full.names=TRUE) # Return: if (length(iw.best) == 0) { list() } else { read.nexus(iw.best[which.max(file.mtime(iw.best))]) } }) omit=c(lon, &#39;Clupeafumosus_socialis&#39;, &#39;Heliomedusa_orienta&#39;, &#39;Haplophrentis_carinatus&#39;) ColPlot(ConsensusWithout(lapply(iw.trees, consensus), omit)) ColMissing(omit) Figure 2.1: Consensus of implied weights analyses at all values of k # Plot consensus results par(mfrow=c(4, 2), mar=rep(0.2, 4)) ColPlot(consensus(lapply(iw.trees, consensus))) text(-0.5, 1, pos=4, &quot;Consensus of all k values&quot;, cex=0.8) # Plot results for each value of k for (i in seq_along(iw.trees)) { ColPlot(consensus(iw.trees[[i]])) text(1, 1, paste0(&#39;k = &#39;, kValues[i]), pos=4) } Figure 2.2: Implied weights results 2.3.2 Equal weights results ew.best &lt;- list.files(&#39;TreeSearch&#39;, pattern=&#39;hy_ew_\\\\d*\\\\.nex&#39;, full.names=TRUE) ew.tree &lt;- read.nexus(file=ew.best[which.max(file.mtime(ew.best))]) ColPlot(consensus(ew.tree)) (#fig:equal weights results in TreeSearch)Strict consensus of equal weights results omit &lt;- c(lon) ColPlot(ConsensusWithout(ew.tree, omit)) ColMissing(omit) Figure 2.3: Strict consensus of equal weights results, taxa excluded References "],
["reconstructions.html", "3 Character reconstructions", " 3 Character reconstructions Here’s how each character maps onto one of the most parsimonious trees (obtained under implied weighting, \\(k = 4.5\\)): These reconstructions were created using the Inapp R package (Brazeau et al., 2017). Full character definitions can be found by browsing the morphological dataset on MorphoBank (project 2800). References "],
["tnt.html", "4 Fitch parsimony 4.1 Implied weights 4.2 Equal weights", " 4 Fitch parsimony Parsimony search was conducted in TNT v1.5 (Pablo A Goloboff &amp; Catalano, 2016) using sectorial and ratchet heuristics under equal and implied weights. We acknowledge the Willi Hennig Society for their sponsorship of the TNT software. 4.1 Implied weights The consensus of all implied weights runs is not very well resolved: This lack of resolution is largely a product of a few wildcard taxa, which obscure relationships that are nevertheless present in all most parsimonious trees: 4.1.1 Paterinids included Figure 4.1: TNT implied weights consensus 4.1.2 Paterinids excluded Figure 4.2: TNT implied weights consensus 4.2 Equal weights Figure 4.3: TNT Equal weights consensus References "],
["bayesian-analysis.html", "5 Bayesian analysis", " 5 Bayesian analysis Bayesian search was conducted in MrBayes v3.2.6 (Ronquist et al., 2012) using the Mk model (Lewis, 2001) with a gamma parameter: lset coding=variable rates=gamma; Branch length was drawn from a dirichlet prior distribution, which is less informative than an exponential model (Rannala, Zhu, &amp; Yang, 2012), but requires a prior mean tree length within about two orders of magnitude of the true value (Zhang, Rannala, &amp; Yang, 2012). To satisfy this latter criterion, we specified the prior mean tree length to be equal to the length of the most parsimonious tree under equal weights, usinga Dirichlet prior with \\(α_T = 1\\), \\(β_T = 1/\\)(equal weights tree length / number of characters), \\(α = c = 1\\): prset brlenspr = unconstrained: gammadir(1, 0.33, 1, 1); Neomorphic and transformational characters (sensu Sereno, 2007) were allocated to two separate partitions whose proportion of invariant characters and gamma shape parameters were allowed to vary independently: charset Neomorphic = 2 3 5 10 13 14 18 19 24 25 29 30 32 34 36 37 38 39 40 43 50 51 53 54 55 60 63 64 67 70 72 73 76 77 78 79 84 88 89 92 94 95; charset Transformational = 1 4 6 7 8 9 11 12 15 16 17 20 21 22 23 26 27 28 31 33 35 41 42 44 45 46 47 48 49 52 56 57 58 59 61 62 65 66 68 69 71 74 75 80 81 82 83 85 86 87 90 91 93; partition chartype = 2: Neomorphic, Transformational; set partition = chartype; unlink shape=(all) pinvar=(all); Neomorphic characters were not assumed to have a symmetrical transition rate – that is, the probability of the absent → present transition was allowed to differ from that of the present → absent transition, being drawn from a uniform prior: prset applyto=(1) symdirihyperpr=fixed(1.0); Four MrBayes runs were executed, each sampling eight chains for 1 000 000 generations, with samples taken every 500 generations: mcmcp ngen=1000000 samplefreq=500 nruns=2 nchains=8; The first 10% of samples were discarded as burn-in (burninfrac=0.1), and a posterior tree topology was derived from the combined posterior sample of both runs. Figure 5.1: Bayesian analysis, posterior probability &gt; 50% Figure 5.2: Bayesian analysis, posterior probability &gt; 50% Convergence was indicated by PSRF = 1.00 and an average estimated sample size of &gt; 500 for each parameter: (#tab:MrBayes parameter summary)MrBayes parameter estimates (.pstat file) Parameter Mean Variance Lower Upper Median minESS avgESS PSRF TL{all} 6.708892 1.624940 4.8329690 9.249889 6.781895 9.742945 877.9326 1.022541 alpha{1} 2.403829 1.536554 0.0001827 4.702963 2.194241 23.533840 1038.9600 1.005475 alpha{2} 2.950148 2.036612 0.0022876 5.567708 2.770201 22.238850 1073.5860 1.004902 It’s interesting to note that the clade of hyoliths + lingulellotretids (+ relatives) is resolved as a grade under Bayesian analysis. In parsimony analysis, these taxa are always resolved as a clade when inapplicable data is correctly handled; they instead resolve as a grade under certain conditions under the standard Fitch algorithm (which mishandles inapplicable data). We suggest that the failure of Bayesian analysis to recover this group as a clade may reflect inappropriate handling of inapplicable data in MrBayes, though at present (and until the algorithms used in a likelihood context are improved) it is difficult to test this hypothesis. The same goes for the position of Gasconsia, which is widely held to have an affinity with the craniid brachiopods, and is recovered in such a position using the inapplicable-safe parsimony algorithm (but not always when the standard Fitch parsimony algorithm is used). "]
]
